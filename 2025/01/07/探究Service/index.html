<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>探究Service | Hexo</title><meta name="author" content="lele"><meta name="copyright" content="lele"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="ServiceService是什么Service是Android中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而 且还要求长期运行的任务。Service的运行不依赖于任何用户界面，即使程序被切换到后台，或 者用户打开了另外一个应用程序，Service仍然能够保持正常运行。 不过需要注意的是，Service并不是运行在一个独立的进程当中的，而是依赖于创建Service时 所在的应用">
<meta property="og:type" content="article">
<meta property="og:title" content="探究Service">
<meta property="og:url" content="http://example.com/2025/01/07/%E6%8E%A2%E7%A9%B6Service/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="ServiceService是什么Service是Android中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而 且还要求长期运行的任务。Service的运行不依赖于任何用户界面，即使程序被切换到后台，或 者用户打开了另外一个应用程序，Service仍然能够保持正常运行。 不过需要注意的是，Service并不是运行在一个独立的进程当中的，而是依赖于创建Service时 所在的应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2025-01-07T10:35:11.000Z">
<meta property="article:modified_time" content="2025-03-25T12:42:33.212Z">
<meta property="article:author" content="lele">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/image/tx.jpg"><link rel="canonical" href="http://example.com/2025/01/07/%E6%8E%A2%E7%A9%B6Service/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '探究Service',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-25 20:42:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/tx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">109</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/test.gif"/><span class="site-name">Hexo</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">探究Service</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-07T10:35:11.000Z" title="发表于 2025-01-07 18:35:11">2025-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-25T12:42:33.212Z" title="更新于 2025-03-25 20:42:33">2025-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="探究Service"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Service是什么"><a href="#Service是什么" class="headerlink" title="Service是什么"></a>Service是什么</h2><p>Service是Android中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而 且还要求长期运行的任务。Service的运行不依赖于任何用户界面，即使程序被切换到后台，或 者用户打开了另外一个应用程序，Service仍然能够保持正常运行。</p>
<p>不过需要注意的是，Service并不是运行在一个独立的进程当中的，而是依赖于创建Service时 所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的Service也会停止运行。</p>
<p>另外，也不要被Service的后台概念所迷惑，实际上Service并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在Service的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。</p>
<h2 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h2><p>当我们需要执行一些耗时操作，比如发 起一条网络请求时，考虑到网速等其他原因，服务器未必能够立刻响应我们的请求，如果不将 这类操作放在子线程里运行，就会导致主线程被阻塞，从而影响用户对软件的正常使用。</p>
<h3 id="线程的基本用法"><a href="#线程的基本用法" class="headerlink" title="线程的基本用法"></a>线程的基本用法</h3><p>义一 个线程只需要新建一个类继承自Thread，然后重写父类的run()方法，并在里面编写耗时逻辑 即可，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> : <span class="type">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么该如何启动这个线程呢？其实很简单，只需要创建MyThread的实例，然后调用它的 start()方法即可，这样run()方法中的代码就会在子线程当中运行了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">MyThread().start()</span><br></pre></td></tr></table></figure>

<p>当然，使用继承的方式耦合性有点高，我们会更多地选择使用实现Runnable接口的方式来定义 一个线程，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> : <span class="type">Runnable</span> &#123; </span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123; </span><br><span class="line">        <span class="comment">// 编写具体的逻辑 </span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用了这种写法，启动线程的方法也需要进行相应的改变，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myThread = MyThread() </span><br><span class="line">Thread(myThread).start() </span><br></pre></td></tr></table></figure>

<p>可以看到，Thread的构造函数接收一个Runnable参数，而我们创建的MyThread实例正是一 个实现了Runnable接口的对象，所以可以直接将它传入Thread的构造函数里。接着调用 Thread的start()方法，run()方法中的代码就会在子线程当中运行了。</p>
<p>当然，如果你不想专门再定义一个类去实现Runnable接口，也可以使用Lambda的方式，这种 写法更为常见，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Thread &#123; </span><br><span class="line"> <span class="comment">// 编写具体的逻辑 </span></span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure>

<p>以上几种线程的使用方式你应该不会感到陌生，因为在Java中创建和启动线程也是使用同样的 方式。而Kotlin还给我们提供了一种更加简单的开启线程的方式，写法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">thread &#123; </span><br><span class="line"> <span class="comment">// 编写具体的逻辑 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的thread是一个Kotlin内置的顶层函数，我们只需要在Lambda表达式中编写具体的逻辑 就可以了，连start()方法都不用调用，thread函数在内部帮我们全部都处理好了。</p>
<h3 id="在子线程中更新UI"><a href="#在子线程中更新UI" class="headerlink" title="在子线程中更新UI"></a>在子线程中更新UI</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>()&#123;</span><br><span class="line">    <span class="keyword">val</span> updateText = <span class="number">1</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> textView : TextView</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> handle = <span class="keyword">object</span> : Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg:<span class="type">Message</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">when</span>(msg.what)&#123;</span><br><span class="line">                updateText -&gt; textView.text = <span class="string">&quot;Nice to meet you&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState : <span class="type">Bundle</span>?)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        textView = binding.textView</span><br><span class="line">        <span class="keyword">val</span> changeTextBtn = binding.changeTextBtn</span><br><span class="line">        changeTextBtn.setOnClickListener&#123;</span><br><span class="line">            thread&#123;</span><br><span class="line">                <span class="keyword">val</span> msg = Message()</span><br><span class="line">                mag.what = updateText</span><br><span class="line">                handle.sendMessage(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析异步消息处理机制"><a href="#解析异步消息处理机制" class="headerlink" title="解析异步消息处理机制"></a>解析异步消息处理机制</h3><p>Android中的异步消息处理主要由4个部分组成：Message、Handler、MessageQueue和Looper。</p>
<ul>
<li><p>Message</p>
<p>Message是在线程之间传递的消息，它可以在内部携带少量的消息，用于在不同线程之间传递数据。</p>
</li>
<li><p>Handler</p>
<p>Handler主要是用于发送和处理消息的，发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中</p>
</li>
<li><p>MessageQueue</p>
<p>MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只有一个MessageQueue对象。</p>
</li>
<li><p>Looper</p>
<p>Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息时，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中只会有一个Looper对象</p>
</li>
</ul>
<h4 id="异步消息处理流程"><a href="#异步消息处理流程" class="headerlink" title="异步消息处理流程"></a>异步消息处理流程</h4><p>首先需要在主线程当中创建一个Handler对象，并重写handleMessage()方法。然后当子线程中国需要进行UI操作时，就创建一个Message对象，并通过Handler将这条消息发送出去。之后这条消息就会被添加到MessageQueue的队列中等待被处理，而Looper则会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler的handleMessage()方法中。由于Handle的构造函数中我们传入了Looper.getMainLooper()，所以此时handleMessage()方法中的代码也会在主线程中运行</p>
<h3 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h3><p>首先来看一下AsyncTask的基本用法。由于AsyncTask是一个抽象类，所以如果我们想使用 它，就必须创建一个子类去继承它。在继承时我们可以为AsyncTask类指定3个泛型参数，这3 个参数的用途如下。</p>
<ul>
<li>Params。在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</li>
<li>Progress。在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为单位进度</li>
<li>Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型</li>
</ul>
<p>因此，一个最简单的自定义AsyncTask就可以写成如下形式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">Unit, Int, Boolean</span>&gt;() &#123; </span><br><span class="line"> 	... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这里我们把AsyncTask的第一个泛型参数指定为Unit，表示在执行AsyncTask的时候不需要传 入参数给后台任务。第二个泛型参数指定为Int，表示使用整型数据来作为进度显示单位。第三 个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。</p>
<p>当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们 还需要重写AsyncTask中的几个方法才能完成对任务的定制。经常需要重写的方法有以下4个。</p>
<ul>
<li><p>onPreExecute()</p>
<p>这个方法回在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等</p>
</li>
<li><p>doInBackground(Params…)</p>
<p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行的结果注意，在这个方法中是不可以进行UI 操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用 publishProgress (Progress…)方法来完成。</p>
</li>
<li><p>onProgressUpdate(Progress…)</p>
<p>当在后台任务中调用了publishProgress(Progress…)方法后， onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是 在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对 界面元素进行相应的更新。</p>
</li>
<li><p>onPostExecute(Result)</p>
<p>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数 据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如说提醒任务执 行的结果，以及关闭进度条对话框等。</p>
</li>
</ul>
<h2 id="Service的基本用法"><a href="#Service的基本用法" class="headerlink" title="Service的基本用法"></a>Service的基本用法</h2><h3 id="定义一个Service"><a href="#定义一个Service" class="headerlink" title="定义一个Service"></a>定义一个Service</h3><p>首先看一下如何在项目中定义一个Service。新建一个ServiceTest项目，然后右击 com.example.servicetest→New→Service→Service，</p>
<p>可以看到，这里我们将类名定义成MyService，Exported属性表示是否将这个Service暴露给 外部其他程序访问，Enabled属性表示是否启用这个Service。将两个属性都勾中，点 击“Finish”完成创建。</p>
<p>现在观察MyService中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123; </span><br><span class="line">     TODO(<span class="string">&quot;Return the communication channel to the service.&quot;</span>) </span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以看到，MyService是继承自系统的Service类的。目前MyService中可以算是空空如也， 但有一个onBind()方法特别醒目。这个方法是Service中唯一的抽象方法，所以必须在子类里 实现。我们会在后面的小节中使用到onBind()方法，目前可以暂时将它忽略。 既然是定义一个Service，自然应该在Service中处理一些事情了，那处理事情的逻辑应该写在 哪里呢？这时就可以重写Service中的另外一些方法了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123; </span><br><span class="line"> ... </span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123; </span><br><span class="line"> <span class="keyword">super</span>.onCreate() </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId) </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123; </span><br><span class="line"> <span class="keyword">super</span>.onDestroy() </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我们又重写了onCreate()、onStartCommand()和onDestroy()这3个方 法，它们是每个Service中最常用到的3个方法了。其中onCreate()方法会在Service创建的 时候调用，onStartCommand()方法会在每次Service启动的时候调用，onDestroy()方法 会在Service销毁的时候调用。</p>
<p>通常情况下，如果我们希望Service一旦启动就立刻去执行某个动作，就可以将逻辑写在 onStartCommand()方法里。而当Service销毁时，我们又应该在onDestroy()方法中回收 那些不再使用的资源。</p>
<h3 id="启动和停止Service"><a href="#启动和停止Service" class="headerlink" title="启动和停止Service"></a>启动和停止Service</h3><p>定义好了Service之后，接下来就应该考虑如何启动以及停止这个Service。启动和停止的方法 当然你也不会陌生，主要是借助Intent来实现的。下面就让我们在ServiceTest项目中尝试启动 以及停止MyService。</p>
<p>修改MainActivity中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState : <span class="type">Bundle</span>?)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="keyword">val</span> startServiceBtn = binding.startServiceBtn</span><br><span class="line">        <span class="keyword">val</span> stopServiceBtn = binding.stopServiceBtn</span><br><span class="line">        startServiceBtn.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyService::<span class="keyword">class</span>.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">        stioServiceBtn.setOnCLickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,Myservice::<span class="keyword">class</span>.java)</span><br><span class="line">            stopService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OnCreate-方法和onStartCommand-方法区别"><a href="#OnCreate-方法和onStartCommand-方法区别" class="headerlink" title="OnCreate()方法和onStartCommand()方法区别"></a>OnCreate()方法和onStartCommand()方法区别</h4><p>onCreate()方法是在Service第一次创建的时候调用的，而onStartCommand()方法则 在每次启动Service的时候都会调用。由于刚才我们是第一次点击“Start Service”按钮， Service此时还未创建过，所以两个方法都会执行，之后如果你再连续多点击几次“Start Service”按钮，你就会发现只有onStartCommand()方法可以得到执行了。</p>
<h3 id="Activity和Service进行通信"><a href="#Activity和Service进行通信" class="headerlink" title="Activity和Service进行通信"></a>Activity和Service进行通信</h3><p>使用onBind()方法</p>
<p>比如说，目前我们希望在MyService里提供一个下载功能，然后在Activity中可以决定何时开始 下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的Binder对象来对下载功 能进行管理。修改MyService中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DownloadBinder</span> : <span class="type">Binder</span>()&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;startDownload executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getProgress</span><span class="params">()</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;getProgress executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent:<span class="type">Intent</span>)</span></span> : IBinder&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我们新建了一个DownloadBinder类，并让它继承自Binder，然后在它的内 部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功 能，我们在这两个方法中分别打印了一行日志。</p>
<p>接着，在MyService中创建了DownloadBinder的实例，然后在onBind()方法里返回了这个 实例，这样MyService中的工作就全部完成了。</p>
<p>下面就要看一看在Activity中如何调用Service里的这些方法了。首先需要在布局文件里新增两 个按钮，修改activity_main.xml中的代码，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">         ... </span><br><span class="line"></span><br><span class="line">             <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:id</span>=<span class="string">&quot;@+id/bindServiceBtn&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:text</span>=<span class="string">&quot;Bind Service&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">             <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:id</span>=<span class="string">&quot;@+id/unbindServiceBtn&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">android:text</span>=<span class="string">&quot;Unbind Service&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这两个按钮分别是用于绑定和取消绑定Service的，那到底谁需要和Service绑定呢？当然就是 Activity了。当一个Activity和Service绑定了之后，就可以调用该Service里的Binder提供的 方法了。修改MainActivity中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>()&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> downloadBinder : MyService.DownloadBinder</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span> : ServiceConnection&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name:<span class="type">ComponentName</span>,service:<span class="type">IBinder</span>)</span></span>&#123;</span><br><span class="line">            downloadBinder = service <span class="keyword">as</span> MyService.DownloadBinder</span><br><span class="line">            downloadBinder.startDownload()</span><br><span class="line">            downloadBinder.getProgress()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name : <span class="type">ComponentName</span>)</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span>&#123;</span><br><span class="line">        、、、</span><br><span class="line">        bindServiceBtn.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">            bindService(intent,connection,Context.BIND_AUTO_CREATE)</span><br><span class="line">        &#125;</span><br><span class="line">        unbindServiceBtn.setOnClickListener&#123;</span><br><span class="line">            unbindService(connection)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h2><p>一旦在项目的任何位置调用了Context的startService()方法，相应的Service就会启动， 并回调onStartCommand()方法。如果这个Service之前还没有创建过，onCreate()方法会 先于onStartCommand()方法执行。Service启动了之后会一直保持运行状态，直到 stopService()或stopSelf()方法被调用，或者被系统回收。注意，虽然每调用一次 startService()方法，onStartCommand()就会执行一次，但实际上每个Service只会存在 一个实例。所以不管你调用了多少次startService()方法，只需调用一次stopService() 或stopSelf()方法，Service就会停止。 另外，还可以调用Context的bindService()来获取一个Service的持久连接，这时就会回调 Service中的onBind()方法。类似地，如果这个Service之前还没有创建过，onCreate()方 法会先于onBind()方法执行。之后，调用方可以获取到onBind()方法里返回的IBinder对象 的实例，这样就能自由地和Service进行通信了。只要调用方和Service之间的连接没有断开， Service就会一直保持运行状态，直到被系统回收。 当调用了startService()方法后，再去调用stopService()方法。这时Service中的 onDestroy()方法就会执行，表示Service已经销毁了。类似地，当调用了bindService() 方法后，再去调用unbindService()方法，onDestroy()方法也会执行，这两种情况都很好 理解。但是需要注意，我们是完全有可能对一个Service既调用了startService()方法，又 调用了bindService()方法的，在这种情况下该如何让Service销毁呢？根据Android系统的 机制，一个Service只要被启动或者被绑定了之后，就会处于运行状态，必须要让以上两种条件 同时不满足，Service才能被销毁。所以，这种情况下要同时调用stopService()和 unbindService()方法，onDestroy()方法才会执行。 这样你就把Service的生命周期完整地走了一遍。</p>
<h2 id="Service的更多技巧"><a href="#Service的更多技巧" class="headerlink" title="Service的更多技巧"></a>Service的更多技巧</h2><h3 id="使用前台Service"><a href="#使用前台Service" class="headerlink" title="使用前台Service"></a>使用前台Service</h3><p>修改MyService中的代 码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span>()&#123;</span><br><span class="line">    、、、</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;onCreate executed&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build&gt;VERSION_CODES<span class="number">.0</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> channel = NotoficationManager(<span class="string">&quot;my_service&quot;</span>,<span class="string">&quot;前台Service通知&quot;</span>,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            	manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">&quot;my_service&quot;</span>)</span><br><span class="line">        	.setContextTitle(<span class="string">&quot;This is content text&quot;</span>)</span><br><span class="line">        	.setSmallIcon(R.drawable.small_icon)</span><br><span class="line">        	.setLargeIcon(BitmapFactory.decodeResource(resoruces,R.drabable.large_icon))</span><br><span class="line">        	.setContentIntent(pi)</span><br><span class="line">        	.build()</span><br><span class="line">        startForeground(<span class="number">1</span>,notification)  	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用startForeground()方法后就会让MyService变成一个前 台Service，并在系统状态栏显示出来。</p>
<p>另外，从Android 9.0系统开始，使用前台Service必须在AndroidManifest.xml文件中进行权 限声明才行，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">package</span>=<span class="string">&quot;com.example.servicetest&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span> /&gt;</span> </span><br><span class="line">         ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>现在即使你退出应用程序，MyService也会一直处于运行状态，而且不用担心会被系统回收。 当然，MyService所对应的通知也会一直显示在状态栏上面。如果用户不希望我们的程序一直 运行，也可以选择手动杀掉应用，这样MyService就会跟着一起停止运行了。</p>
<h3 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h3><p>Android专门提供了一个 IntentService类，这个类就很好地解决了前面所提到的两种尴尬，下面我们就来看一下它的用法。</p>
<p>新建一个MyIntentService类继承自IntentService，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIntentService</span> : <span class="type">IntentService</span>(<span class="string">&quot;MyIntentService&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHandleIntent</span><span class="params">(intent:<span class="type">Intent</span>?)</span></span>&#123;</span><br><span class="line">        <span class="comment">//打印当前线程的id</span></span><br><span class="line">        Log.d(<span class="string">&quot;MyIntentService&quot;</span>, <span class="string">&quot;Thread id is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        Log.d(<span class="string">&quot;MyIntentService&quot;</span>,<span class="string">&quot;onDestroy executed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来修改activity_main.xml中的代码，加入一个用于启动MyIntentService的按钮，如下 所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line">     ... </span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">Button</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">&quot;@+id/startIntentServiceBtn&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">android:text</span>=<span class="string">&quot;Start IntentService&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>然后修改MainActivity中的代码，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>()&#123;</span><br><span class="line">    、、、</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState:<span class="type">Bundle</span>?)</span></span>&#123;</span><br><span class="line">        、、、</span><br><span class="line">        startIntentServiceBtn.setOnClickListener&#123;</span><br><span class="line">            <span class="comment">//打印主线程的id</span></span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;Thread id is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyIntentService::<span class="keyword">class</span>.java)</span><br><span class="line">            startService(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在“Start IntentService”按钮的点击事件里启动了MyIntentService，并在这 里打印了一下主线程名，稍后用于和IntentService进行比对。你会发现，其实IntentService 的启动方式和普通的Service没什么两样</p>
<p>最后不要忘记，Service都是需要在AndroidManifest.xml里注册的，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">、、、</span><br><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:name</span>=<span class="string">&quot;MyIntentService&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">         /&gt;</span></span><br><span class="line">、、、</span><br></pre></td></tr></table></figure>

<h2 id="Kotlin课堂：泛型的高级特性"><a href="#Kotlin课堂：泛型的高级特性" class="headerlink" title="Kotlin课堂：泛型的高级特性"></a>Kotlin课堂：泛型的高级特性</h2><h3 id="对泛型进行实化"><a href="#对泛型进行实化" class="headerlink" title="对泛型进行实化"></a>对泛型进行实化</h3><p>那么具体该怎么写才能将泛型实化呢？首先，该函数必须是内联函数才行，也就是要用inline 关键字来修饰该函数。其次，在声明泛型的地方必须加上reified关键字来表示该泛型要进行 实化。示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数中的泛型T就是一个被实化的泛型，因为它满足了内联函数和reified关键字这两个前 提条件。那么借助泛型实化，到底可以实现什么样的效果呢？从函数名就可以看出来了，这里 我们准备实现一个获取泛型实际类型的功能，代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getGenericType</span><span class="params">()</span></span> = T::<span class="keyword">class</span>.java </span><br></pre></td></tr></table></figure>

<p>虽然只有一行代码，但是这里却实现了一个Java中完全不可能实现的功能： getGenericType()函数直接返回了当前指定泛型的实际类型。T.class这样的语法在Java 中是不合法的，而在Kotlin中，借助泛型实化功能就可以使用T::class.java这样的语法了</p>
<p>现在我们可以使用如下代码对getGenericType()函数进行测试：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">     <span class="keyword">val</span> result1 = getGenericType&lt;String&gt;() </span><br><span class="line">     <span class="keyword">val</span> result2 = getGenericType&lt;<span class="built_in">Int</span>&gt;() </span><br><span class="line">     println(<span class="string">&quot;result1 is <span class="variable">$result1</span>&quot;</span>) </span><br><span class="line">     println(<span class="string">&quot;result2 is <span class="variable">$result2</span>&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型实化的应用"><a href="#泛型实化的应用" class="headerlink" title="泛型实化的应用"></a>泛型实化的应用</h3><p>新建一个reiﬁed.kt文件，然后在里面编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123; </span><br><span class="line">     <span class="keyword">val</span> intent = Intent(context, T::<span class="keyword">class</span>.java) </span><br><span class="line">     context.startActivity(intent) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个startActivity()函数，该函数接收一个Context参数，并同时使用 inline和reified关键字让泛型T成为了一个被实化的泛型。接下来就是神奇的地方了， Intent接收的第二个参数本来应该是一个具体Activity的Class类型，但由于现在T已经是一个 被实化的泛型了，因此这里我们可以直接传入T::class.java。最后调用Context的 startActivity()方法来完成Activity的启动</p>
<p>现在，如果我们想要启动TestActivity，只需要这样写就可以了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) </span><br></pre></td></tr></table></figure>

<p>添加一个新的startActivity()函数重载，如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>, block: <span class="type">Intent</span>.() -&gt; <span class="type">Unit</span>)</span></span> &#123; </span><br><span class="line">     <span class="keyword">val</span> intent = Intent(context, T::<span class="keyword">class</span>.java) </span><br><span class="line">     intent.block() </span><br><span class="line">     context.startActivity(intent) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以看到，这次的startActivity()函数中增加了一个函数类型参数，并且它的函数类型是 定义在Intent类当中的。在创建完Intent的实例之后，随即调用该函数类型参数，并把Intent的 实例传入，这样调用startActivity()函数的时候就可以在Lambda表达式中为Intent传递 参数了，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startActivity&lt;TestActivity&gt;(context) &#123; </span><br><span class="line">     putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data&quot;</span>) </span><br><span class="line">     putExtra(<span class="string">&quot;param2&quot;</span>, <span class="number">123</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">lele</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/01/07/%E6%8E%A2%E7%A9%B6Service/">http://example.com/2025/01/07/%E6%8E%A2%E7%A9%B6Service/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/09/Android%E7%BD%91%E7%BB%9C/" title="Android网络"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android网络</div></div></a></div><div class="next-post pull-right"><a href="/2025/01/05/%E8%BF%90%E7%94%A8%E6%89%8B%E6%9C%BA%E5%A4%9A%E5%AA%92%E4%BD%93/" title="运用手机多媒体"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">运用手机多媒体</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Service"><span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">Service是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">Android多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">线程的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9B%B4%E6%96%B0UI"><span class="toc-text">在子线程中更新UI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">解析异步消息处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-text">异步消息处理流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8AsyncTask"><span class="toc-text">使用AsyncTask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">Service的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAService"><span class="toc-text">定义一个Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2Service"><span class="toc-text">启动和停止Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OnCreate-%E6%96%B9%E6%B3%95%E5%92%8ConStartCommand-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-text">OnCreate()方法和onStartCommand()方法区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity%E5%92%8CService%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">Activity和Service进行通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Service的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%8A%80%E5%B7%A7"><span class="toc-text">Service的更多技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E5%8F%B0Service"><span class="toc-text">使用前台Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8IntentService"><span class="toc-text">使用IntentService</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin%E8%AF%BE%E5%A0%82%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">Kotlin课堂：泛型的高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%B3%9B%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AE%9E%E5%8C%96"><span class="toc-text">对泛型进行实化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">泛型实化的应用</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By lele</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>