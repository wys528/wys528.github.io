<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Dex完整代码解析 | Hexo</title><meta name="author" content="lele"><meta name="copyright" content="lele"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DexFile.h&#x2F;* * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the">
<meta property="og:type" content="article">
<meta property="og:title" content="Dex完整代码解析">
<meta property="og:url" content="http://example.com/2024/07/26/Dex%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="DexFile.h&#x2F;* * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-07-26T14:41:47.000Z">
<meta property="article:modified_time" content="2024-07-26T14:41:58.316Z">
<meta property="article:author" content="lele">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/image/tx.jpg"><link rel="canonical" href="http://example.com/2024/07/26/Dex%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dex完整代码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-26 22:41:58'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/tx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><img class="site-icon" src="/image/test.gif"/><span class="site-name">Hexo</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Dex完整代码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-26T14:41:47.000Z" title="发表于 2024-07-26 22:41:47">2024-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-26T14:41:58.316Z" title="更新于 2024-07-26 22:41:58">2024-07-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Dex完整代码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="DexFile-h"><a href="#DexFile-h" class="headerlink" title="DexFile.h"></a>DexFile.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2008 The Android Open Source Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Access .dex (Dalvik Executable Format) files.  The code here assumes that</span></span><br><span class="line"><span class="comment"> * the DEX file has been rewritten (byte-swapped, word-aligned) and that</span></span><br><span class="line"><span class="comment"> * the contents can be directly accessed as a collection of C arrays.  Please</span></span><br><span class="line"><span class="comment"> * see docs/dalvik/dex-format.html for a detailed description.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The structure and field names were chosen to match those in the DEX spec.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It&#x27;s generally assumed that the DEX file will be stored in shared memory,</span></span><br><span class="line"><span class="comment"> * obviating the need to copy code and constant pool entries into newly</span></span><br><span class="line"><span class="comment"> * allocated storage.  Maintaining local pointers to items in the shared area</span></span><br><span class="line"><span class="comment"> * is valid and encouraged.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All memory-mapped structures are 32-bit aligned unless otherwise noted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIBDEX_DEXFILE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIBDEX_DEXFILE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vm/Common.h&quot;</span>      <span class="comment">// basic type defs, e.g. u1/u2/u4/u8, and LOG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;libdex/SysUtil.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gcc-style inline management -- ensures we have a copy of all functions</span></span><br><span class="line"><span class="comment"> * in the library, so code that links against us will work whether or not</span></span><br><span class="line"><span class="comment"> * it was built with optimizations enabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DEX_GEN_INLINES             <span class="comment">/* only defined by DexInlines.c */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DEX_INLINE extern __inline__</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DEX_INLINE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DEX file magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_MAGIC       <span class="string">&quot;dex\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* current version, encoded in 4 bytes of ASCII */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_MAGIC_VERS  <span class="string">&quot;036\0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * older but still-recognized version (corresponding to Android API</span></span><br><span class="line"><span class="comment"> * levels 13 and earlier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_MAGIC_VERS_API_13  <span class="string">&quot;035\0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* same, but for optimized DEX header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_OPT_MAGIC   <span class="string">&quot;dey\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_OPT_MAGIC_VERS  <span class="string">&quot;036\0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_DEP_MAGIC   <span class="string">&quot;deps&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 160-bit SHA-1 digest.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> &#123; kSHA1DigestLen = <span class="number">20</span>,</span><br><span class="line">       kSHA1DigestOutputLen = kSHA1DigestLen*<span class="number">2</span> <span class="number">+1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* general constants */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexEndianConstant = <span class="number">0x12345678</span>,    <span class="comment">/* the endianness indicator */</span></span><br><span class="line">    kDexNoIndex = <span class="number">0xffffffff</span>,           <span class="comment">/* not a valid index value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enumeration of all the primitive types.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">PrimitiveType</span> &#123;</span><br><span class="line">    PRIM_NOT        = <span class="number">0</span>,       <span class="comment">/* value is a reference type, not a primitive type */</span></span><br><span class="line">    PRIM_VOID       = <span class="number">1</span>,</span><br><span class="line">    PRIM_BOOLEAN    = <span class="number">2</span>,</span><br><span class="line">    PRIM_BYTE       = <span class="number">3</span>,</span><br><span class="line">    PRIM_SHORT      = <span class="number">4</span>,</span><br><span class="line">    PRIM_CHAR       = <span class="number">5</span>,</span><br><span class="line">    PRIM_INT        = <span class="number">6</span>,</span><br><span class="line">    PRIM_LONG       = <span class="number">7</span>,</span><br><span class="line">    PRIM_FLOAT      = <span class="number">8</span>,</span><br><span class="line">    PRIM_DOUBLE     = <span class="number">9</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * access flags and masks; the &quot;standard&quot; ones are all &lt;= 0x4000</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: There are related declarations in vm/oo/Object.h in the ClassFlags</span></span><br><span class="line"><span class="comment"> * enum.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    ACC_PUBLIC       = <span class="number">0x00000001</span>,       <span class="comment">// class, field, method, ic</span></span><br><span class="line">    ACC_PRIVATE      = <span class="number">0x00000002</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_PROTECTED    = <span class="number">0x00000004</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_STATIC       = <span class="number">0x00000008</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_FINAL        = <span class="number">0x00000010</span>,       <span class="comment">// class, field, method, ic</span></span><br><span class="line">    ACC_SYNCHRONIZED = <span class="number">0x00000020</span>,       <span class="comment">// method (only allowed on natives)</span></span><br><span class="line">    ACC_SUPER        = <span class="number">0x00000020</span>,       <span class="comment">// class (not used in Dalvik)</span></span><br><span class="line">    ACC_VOLATILE     = <span class="number">0x00000040</span>,       <span class="comment">// field</span></span><br><span class="line">    ACC_BRIDGE       = <span class="number">0x00000040</span>,       <span class="comment">// method (1.5)</span></span><br><span class="line">    ACC_TRANSIENT    = <span class="number">0x00000080</span>,       <span class="comment">// field</span></span><br><span class="line">    ACC_VARARGS      = <span class="number">0x00000080</span>,       <span class="comment">// method (1.5)</span></span><br><span class="line">    ACC_NATIVE       = <span class="number">0x00000100</span>,       <span class="comment">// method</span></span><br><span class="line">    ACC_INTERFACE    = <span class="number">0x00000200</span>,       <span class="comment">// class, ic</span></span><br><span class="line">    ACC_ABSTRACT     = <span class="number">0x00000400</span>,       <span class="comment">// class, method, ic</span></span><br><span class="line">    ACC_STRICT       = <span class="number">0x00000800</span>,       <span class="comment">// method</span></span><br><span class="line">    ACC_SYNTHETIC    = <span class="number">0x00001000</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_ANNOTATION   = <span class="number">0x00002000</span>,       <span class="comment">// class, ic (1.5)</span></span><br><span class="line">    ACC_ENUM         = <span class="number">0x00004000</span>,       <span class="comment">// class, field, ic (1.5)</span></span><br><span class="line">    ACC_CONSTRUCTOR  = <span class="number">0x00010000</span>,       <span class="comment">// method (Dalvik only)</span></span><br><span class="line">    ACC_DECLARED_SYNCHRONIZED =</span><br><span class="line">                       <span class="number">0x00020000</span>,       <span class="comment">// method (Dalvik only)</span></span><br><span class="line">    ACC_CLASS_MASK =</span><br><span class="line">        (ACC_PUBLIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT</span><br><span class="line">                | ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM),</span><br><span class="line">    ACC_INNER_CLASS_MASK =</span><br><span class="line">        (ACC_CLASS_MASK | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC),</span><br><span class="line">    ACC_FIELD_MASK =</span><br><span class="line">        (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL</span><br><span class="line">                | ACC_VOLATILE | ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM),</span><br><span class="line">    ACC_METHOD_MASK =</span><br><span class="line">        (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL</span><br><span class="line">                | ACC_SYNCHRONIZED | ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE</span><br><span class="line">                | ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC | ACC_CONSTRUCTOR</span><br><span class="line">                | ACC_DECLARED_SYNCHRONIZED),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* annotation constants */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexVisibilityBuild         = <span class="number">0x00</span>,     <span class="comment">/* annotation visibility */</span></span><br><span class="line">    kDexVisibilityRuntime       = <span class="number">0x01</span>,</span><br><span class="line">    kDexVisibilitySystem        = <span class="number">0x02</span>,</span><br><span class="line"></span><br><span class="line">    kDexAnnotationByte          = <span class="number">0x00</span>,</span><br><span class="line">    kDexAnnotationShort         = <span class="number">0x02</span>,</span><br><span class="line">    kDexAnnotationChar          = <span class="number">0x03</span>,</span><br><span class="line">    kDexAnnotationInt           = <span class="number">0x04</span>,</span><br><span class="line">    kDexAnnotationLong          = <span class="number">0x06</span>,</span><br><span class="line">    kDexAnnotationFloat         = <span class="number">0x10</span>,</span><br><span class="line">    kDexAnnotationDouble        = <span class="number">0x11</span>,</span><br><span class="line">    kDexAnnotationString        = <span class="number">0x17</span>,</span><br><span class="line">    kDexAnnotationType          = <span class="number">0x18</span>,</span><br><span class="line">    kDexAnnotationField         = <span class="number">0x19</span>,</span><br><span class="line">    kDexAnnotationMethod        = <span class="number">0x1a</span>,</span><br><span class="line">    kDexAnnotationEnum          = <span class="number">0x1b</span>,</span><br><span class="line">    kDexAnnotationArray         = <span class="number">0x1c</span>,</span><br><span class="line">    kDexAnnotationAnnotation    = <span class="number">0x1d</span>,</span><br><span class="line">    kDexAnnotationNull          = <span class="number">0x1e</span>,</span><br><span class="line">    kDexAnnotationBoolean       = <span class="number">0x1f</span>,</span><br><span class="line"></span><br><span class="line">    kDexAnnotationValueTypeMask = <span class="number">0x1f</span>,     <span class="comment">/* low 5 bits */</span></span><br><span class="line">    kDexAnnotationValueArgShift = <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* map item type codes */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexTypeHeaderItem               = <span class="number">0x0000</span>,</span><br><span class="line">    kDexTypeStringIdItem             = <span class="number">0x0001</span>,</span><br><span class="line">    kDexTypeTypeIdItem               = <span class="number">0x0002</span>,</span><br><span class="line">    kDexTypeProtoIdItem              = <span class="number">0x0003</span>,</span><br><span class="line">    kDexTypeFieldIdItem              = <span class="number">0x0004</span>,</span><br><span class="line">    kDexTypeMethodIdItem             = <span class="number">0x0005</span>,</span><br><span class="line">    kDexTypeClassDefItem             = <span class="number">0x0006</span>,</span><br><span class="line">    kDexTypeMapList                  = <span class="number">0x1000</span>,</span><br><span class="line">    kDexTypeTypeList                 = <span class="number">0x1001</span>,</span><br><span class="line">    kDexTypeAnnotationSetRefList     = <span class="number">0x1002</span>,</span><br><span class="line">    kDexTypeAnnotationSetItem        = <span class="number">0x1003</span>,</span><br><span class="line">    kDexTypeClassDataItem            = <span class="number">0x2000</span>,</span><br><span class="line">    kDexTypeCodeItem                 = <span class="number">0x2001</span>,</span><br><span class="line">    kDexTypeStringDataItem           = <span class="number">0x2002</span>,</span><br><span class="line">    kDexTypeDebugInfoItem            = <span class="number">0x2003</span>,</span><br><span class="line">    kDexTypeAnnotationItem           = <span class="number">0x2004</span>,</span><br><span class="line">    kDexTypeEncodedArrayItem         = <span class="number">0x2005</span>,</span><br><span class="line">    kDexTypeAnnotationsDirectoryItem = <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* auxillary data section chunk codes */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexChunkClassLookup            = <span class="number">0x434c4b50</span>,   <span class="comment">/* CLKP */</span></span><br><span class="line">    kDexChunkRegisterMaps           = <span class="number">0x524d4150</span>,   <span class="comment">/* RMAP */</span></span><br><span class="line"></span><br><span class="line">    kDexChunkEnd                    = <span class="number">0x41454e44</span>,   <span class="comment">/* AEND */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* debug info opcodes and constants */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DBG_END_SEQUENCE         = <span class="number">0x00</span>,</span><br><span class="line">    DBG_ADVANCE_PC           = <span class="number">0x01</span>,</span><br><span class="line">    DBG_ADVANCE_LINE         = <span class="number">0x02</span>,</span><br><span class="line">    DBG_START_LOCAL          = <span class="number">0x03</span>,</span><br><span class="line">    DBG_START_LOCAL_EXTENDED = <span class="number">0x04</span>,</span><br><span class="line">    DBG_END_LOCAL            = <span class="number">0x05</span>,</span><br><span class="line">    DBG_RESTART_LOCAL        = <span class="number">0x06</span>,</span><br><span class="line">    DBG_SET_PROLOGUE_END     = <span class="number">0x07</span>,</span><br><span class="line">    DBG_SET_EPILOGUE_BEGIN   = <span class="number">0x08</span>,</span><br><span class="line">    DBG_SET_FILE             = <span class="number">0x09</span>,</span><br><span class="line">    DBG_FIRST_SPECIAL        = <span class="number">0x0a</span>,</span><br><span class="line">    DBG_LINE_BASE            = <span class="number">-4</span>,</span><br><span class="line">    DBG_LINE_RANGE           = <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;header_item&quot; struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexHeader</span> &#123;</span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* includes version number */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 checksum */</span></span><br><span class="line">    u1  signature[kSHA1DigestLen]; <span class="comment">/* SHA-1 hash */</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* length of entire file */</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* offset to start of next section */</span></span><br><span class="line">    u4  endianTag;</span><br><span class="line">    u4  linkSize;</span><br><span class="line">    u4  linkOff;</span><br><span class="line">    u4  mapOff;</span><br><span class="line">    u4  stringIdsSize;</span><br><span class="line">    u4  stringIdsOff;</span><br><span class="line">    u4  typeIdsSize;</span><br><span class="line">    u4  typeIdsOff;</span><br><span class="line">    u4  protoIdsSize;</span><br><span class="line">    u4  protoIdsOff;</span><br><span class="line">    u4  fieldIdsSize;</span><br><span class="line">    u4  fieldIdsOff;</span><br><span class="line">    u4  methodIdsSize;</span><br><span class="line">    u4  methodIdsOff;</span><br><span class="line">    u4  classDefsSize;</span><br><span class="line">    u4  classDefsOff;</span><br><span class="line">    u4  dataSize;</span><br><span class="line">    u4  dataOff;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;map_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexMapItem</span> &#123;</span><br><span class="line">    u2 type;              <span class="comment">/* type code (see kDexType* above) */</span></span><br><span class="line">    u2 unused;</span><br><span class="line">    u4 size;              <span class="comment">/* count of items of the indicated type */</span></span><br><span class="line">    u4 offset;            <span class="comment">/* file offset to the start of data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;map_list&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexMapList</span> &#123;</span><br><span class="line">    u4  size;               <span class="comment">/* #of entries in list */</span></span><br><span class="line">    DexMapItem list[<span class="number">1</span>];     <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;string_id_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexStringId</span> &#123;</span><br><span class="line">    u4 stringDataOff;      <span class="comment">/* file offset to string_data_item */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;type_id_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexTypeId</span> &#123;</span><br><span class="line">    u4  descriptorIdx;      <span class="comment">/* index into stringIds list for type descriptor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;field_id_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexFieldId</span> &#123;</span><br><span class="line">    u2  classIdx;           <span class="comment">/* index into typeIds list for defining class */</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* index into typeIds for field type */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* index into stringIds for field name */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;method_id_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexMethodId</span> &#123;</span><br><span class="line">    u2  classIdx;           <span class="comment">/* index into typeIds list for defining class */</span></span><br><span class="line">    u2  protoIdx;           <span class="comment">/* index into protoIds for method prototype */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* index into stringIds for method name */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;proto_id_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexProtoId</span> &#123;</span><br><span class="line">    u4  shortyIdx;          <span class="comment">/* index into stringIds for shorty descriptor */</span></span><br><span class="line">    u4  returnTypeIdx;      <span class="comment">/* index into typeIds list for return type */</span></span><br><span class="line">    u4  parametersOff;      <span class="comment">/* file offset to type_list for parameter types */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;class_def_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexClassDef</span> &#123;</span><br><span class="line">    u4  classIdx;           <span class="comment">/* index into typeIds for this class */</span></span><br><span class="line">    u4  accessFlags;</span><br><span class="line">    u4  superclassIdx;      <span class="comment">/* index into typeIds for superclass */</span></span><br><span class="line">    u4  interfacesOff;      <span class="comment">/* file offset to DexTypeList */</span></span><br><span class="line">    u4  sourceFileIdx;      <span class="comment">/* index into stringIds for source file name */</span></span><br><span class="line">    u4  annotationsOff;     <span class="comment">/* file offset to annotations_directory_item */</span></span><br><span class="line">    u4  classDataOff;       <span class="comment">/* file offset to class_data_item */</span></span><br><span class="line">    u4  staticValuesOff;    <span class="comment">/* file offset to DexEncodedArray */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;type_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexTypeItem</span> &#123;</span><br><span class="line">    u2  typeIdx;            <span class="comment">/* index into typeIds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;type_list&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexTypeList</span> &#123;</span><br><span class="line">    u4  size;               <span class="comment">/* #of entries in list */</span></span><br><span class="line">    DexTypeItem list[<span class="number">1</span>];    <span class="comment">/* entries */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;code_item&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &quot;catches&quot; table is used when throwing an exception,</span></span><br><span class="line"><span class="comment"> * &quot;debugInfo&quot; is used when displaying an exception stack trace or</span></span><br><span class="line"><span class="comment"> * debugging. An offset of zero indicates that there are no entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexCode</span> &#123;</span><br><span class="line">    u2  registersSize;</span><br><span class="line">    u2  insSize;</span><br><span class="line">    u2  outsSize;</span><br><span class="line">    u2  triesSize;</span><br><span class="line">    u4  debugInfoOff;       <span class="comment">/* file offset to debug info stream */</span></span><br><span class="line">    u4  insnsSize;          <span class="comment">/* size of the insns array, in u2 units */</span></span><br><span class="line">    u2  insns[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">/* followed by optional u2 padding */</span></span><br><span class="line">    <span class="comment">/* followed by try_item[triesSize] */</span></span><br><span class="line">    <span class="comment">/* followed by uleb128 handlersSize */</span></span><br><span class="line">    <span class="comment">/* followed by catch_handler_item[handlersSize] */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;try_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexTry</span> &#123;</span><br><span class="line">    u4  startAddr;          <span class="comment">/* start address, in 16-bit code units */</span></span><br><span class="line">    u2  insnCount;          <span class="comment">/* instruction count, in 16-bit code units */</span></span><br><span class="line">    u2  handlerOff;         <span class="comment">/* offset in encoded handler data to handlers */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Link table.  Currently undefined.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexLink</span> &#123;</span><br><span class="line">    u1  bleargh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;annotations_directory_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexAnnotationsDirectoryItem</span> &#123;</span><br><span class="line">    u4  classAnnotationsOff;  <span class="comment">/* offset to DexAnnotationSetItem */</span></span><br><span class="line">    u4  fieldsSize;           <span class="comment">/* count of DexFieldAnnotationsItem */</span></span><br><span class="line">    u4  methodsSize;          <span class="comment">/* count of DexMethodAnnotationsItem */</span></span><br><span class="line">    u4  parametersSize;       <span class="comment">/* count of DexParameterAnnotationsItem */</span></span><br><span class="line">    <span class="comment">/* followed by DexFieldAnnotationsItem[fieldsSize] */</span></span><br><span class="line">    <span class="comment">/* followed by DexMethodAnnotationsItem[methodsSize] */</span></span><br><span class="line">    <span class="comment">/* followed by DexParameterAnnotationsItem[parametersSize] */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;field_annotations_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexFieldAnnotationsItem</span> &#123;</span><br><span class="line">    u4  fieldIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* offset to DexAnnotationSetItem */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;method_annotations_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexMethodAnnotationsItem</span> &#123;</span><br><span class="line">    u4  methodIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* offset to DexAnnotationSetItem */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;parameter_annotations_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexParameterAnnotationsItem</span> &#123;</span><br><span class="line">    u4  methodIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* offset to DexAnotationSetRefList */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;annotation_set_ref_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexAnnotationSetRefItem</span> &#123;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* offset to DexAnnotationSetItem */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;annotation_set_ref_list&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexAnnotationSetRefList</span> &#123;</span><br><span class="line">    u4  size;</span><br><span class="line">    DexAnnotationSetRefItem list[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;annotation_set_item&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexAnnotationSetItem</span> &#123;</span><br><span class="line">    u4  size;</span><br><span class="line">    u4  entries[<span class="number">1</span>];                 <span class="comment">/* offset to DexAnnotationItem */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;annotation_item&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this structure is byte-aligned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexAnnotationItem</span> &#123;</span><br><span class="line">    u1  visibility;</span><br><span class="line">    u1  annotation[<span class="number">1</span>];              <span class="comment">/* data in encoded_annotation format */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direct-mapped &quot;encoded_array&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> this structure is byte-aligned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexEncodedArray</span> &#123;</span><br><span class="line">    u1  array[<span class="number">1</span>];                   <span class="comment">/* data in encoded_array format */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lookup table for classes.  It provides a mapping from class name to</span></span><br><span class="line"><span class="comment"> * class definition.  Used by dexFindClass().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We calculate this at DEX optimization time and embed it in the file so we</span></span><br><span class="line"><span class="comment"> * don&#x27;t need the same hash table in every VM.  This is slightly slower than</span></span><br><span class="line"><span class="comment"> * a hash table with direct pointers to the items, but because it&#x27;s shared</span></span><br><span class="line"><span class="comment"> * there&#x27;s less of a penalty for using a fairly sparse table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexClassLookup</span> &#123;</span><br><span class="line">    <span class="type">int</span>     size;                       <span class="comment">// total size, including &quot;size&quot;</span></span><br><span class="line">    <span class="type">int</span>     numEntries;                 <span class="comment">// size of table[]; always power of 2</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        u4      classDescriptorHash;    <span class="comment">// class descriptor hash code</span></span><br><span class="line">        <span class="type">int</span>     classDescriptorOffset;  <span class="comment">// in bytes, from start of DEX</span></span><br><span class="line">        <span class="type">int</span>     classDefOffset;         <span class="comment">// in bytes, from start of DEX</span></span><br><span class="line">    &#125; table[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Header added by DEX optimization pass.  Values are always written in</span></span><br><span class="line"><span class="comment"> * local byte and structure padding.  The first field (magic + version)</span></span><br><span class="line"><span class="comment"> * is guaranteed to be present and directly readable for all expected</span></span><br><span class="line"><span class="comment"> * compiler configurations; the rest is version-dependent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Try to keep this simple and fixed-size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexOptHeader</span> &#123;</span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* includes version number */</span></span><br><span class="line"></span><br><span class="line">    u4  dexOffset;          <span class="comment">/* file offset of DEX header */</span></span><br><span class="line">    u4  dexLength;</span><br><span class="line">    u4  depsOffset;         <span class="comment">/* offset of optimized DEX dependency table */</span></span><br><span class="line">    u4  depsLength;</span><br><span class="line">    u4  optOffset;          <span class="comment">/* file offset of optimized data tables */</span></span><br><span class="line">    u4  optLength;</span><br><span class="line"></span><br><span class="line">    u4  flags;              <span class="comment">/* some info flags */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 checksum covering deps/opt */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pad for 64-bit alignment if necessary */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_OPT_FLAG_BIG            (1&lt;&lt;1)  <span class="comment">/* swapped to big-endian */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEX_INTERFACE_CACHE_SIZE    128     <span class="comment">/* must be power of 2 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure representing a DEX file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Code should regard DexFile as opaque, using the API calls provided here</span></span><br><span class="line"><span class="comment"> * to access specific structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DexFile</span> &#123;</span><br><span class="line">    <span class="comment">/* directly-mapped &quot;opt&quot; header */</span></span><br><span class="line">    <span class="type">const</span> DexOptHeader* pOptHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pointers to directly-mapped structs and arrays in base DEX */</span></span><br><span class="line">    <span class="type">const</span> DexHeader*    pHeader;</span><br><span class="line">    <span class="type">const</span> DexStringId*  pStringIds;</span><br><span class="line">    <span class="type">const</span> DexTypeId*    pTypeIds;</span><br><span class="line">    <span class="type">const</span> DexFieldId*   pFieldIds;</span><br><span class="line">    <span class="type">const</span> DexMethodId*  pMethodIds;</span><br><span class="line">    <span class="type">const</span> DexProtoId*   pProtoIds;</span><br><span class="line">    <span class="type">const</span> DexClassDef*  pClassDefs;</span><br><span class="line">    <span class="type">const</span> DexLink*      pLinkData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * These are mapped out of the &quot;auxillary&quot; section, and may not be</span></span><br><span class="line"><span class="comment">     * included in the file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> DexClassLookup* pClassLookup;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*         pRegisterMapPool;       <span class="comment">// RegisterMapClassPool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* points to start of DEX file data */</span></span><br><span class="line">    <span class="type">const</span> u1*           baseAddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* track memory overhead for auxillary structures */</span></span><br><span class="line">    <span class="type">int</span>                 overhead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* additional app-specific data structures associated with the DEX */</span></span><br><span class="line">    <span class="comment">//void*               auxData;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Utility function -- rounds up to the nearest power of 2.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u4 <span class="title">dexRoundUpPower2</span><span class="params">(u4 val)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Parse an optimized or unoptimized .dex file sitting in memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success, return a newly-allocated DexFile.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DexFile* <span class="title">dexFileParse</span><span class="params">(<span class="type">const</span> u1* data, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bit values for &quot;flags&quot; argument to dexFileParse */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    kDexParseDefault            = <span class="number">0</span>,</span><br><span class="line">    kDexParseVerifyChecksum     = <span class="number">1</span>,</span><br><span class="line">    kDexParseContinueOnError    = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fix the byte ordering of all fields in the DEX file, and do</span></span><br><span class="line"><span class="comment"> * structural verification. This is only required for code that opens</span></span><br><span class="line"><span class="comment"> * &quot;raw&quot; DEX files, such as the DEX optimizer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dexSwapAndVerify</span><span class="params">(u1* addr, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Detect the file type of the given memory buffer via magic number.</span></span><br><span class="line"><span class="comment"> * Call dexSwapAndVerify() on an unoptimized DEX file, do nothing</span></span><br><span class="line"><span class="comment"> * but return successfully on an optimized DEX file, and report an</span></span><br><span class="line"><span class="comment"> * error for all other cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return 0 on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dexSwapAndVerifyIfNecessary</span><span class="params">(u1* addr, <span class="type">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check to see if the file magic and format version in the given</span></span><br><span class="line"><span class="comment"> * header are recognized as valid. Returns true if they are</span></span><br><span class="line"><span class="comment"> * acceptable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dexHasValidMagic</span><span class="params">(<span class="type">const</span> DexHeader* pHeader)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compute DEX checksum.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u4 <span class="title">dexComputeChecksum</span><span class="params">(<span class="type">const</span> DexHeader* pHeader)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Free a DexFile structure, along with any associated structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dexFileFree</span><span class="params">(DexFile* pDexFile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create class lookup table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DexClassLookup* <span class="title">dexCreateClassLookup</span><span class="params">(DexFile* pDexFile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find a class definition by descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">const</span> DexClassDef* <span class="title">dexFindClass</span><span class="params">(<span class="type">const</span> DexFile* pFile, <span class="type">const</span> <span class="type">char</span>* descriptor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the basic raw data pointers of a DexFile. This function isn&#x27;t</span></span><br><span class="line"><span class="comment"> * meant for general use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dexFileSetupBasicPointers</span><span class="params">(DexFile* pDexFile, <span class="type">const</span> u1* data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the DexMapList of the file, if any */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexMapList* <span class="title">dexGetMap</span><span class="params">(<span class="type">const</span> DexFile* pDexFile)</span> </span>&#123;</span><br><span class="line">    u4 mapOff = pDexFile-&gt;pHeader-&gt;mapOff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapOff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="type">const</span> DexMapList*) (pDexFile-&gt;baseAddr + mapOff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the const char* string data referred to by the given string_id */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> <span class="type">char</span>* <span class="title">dexGetStringData</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> DexStringId* pStringId)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> u1* ptr = pDexFile-&gt;baseAddr + pStringId-&gt;stringDataOff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip the uleb128 length.</span></span><br><span class="line">    <span class="keyword">while</span> (*(ptr++) &gt; <span class="number">0x7f</span>) <span class="comment">/* empty */</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span>*) ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* return the StringId with the specified index */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexStringId* <span class="title">dexGetStringId</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pDexFile-&gt;pHeader-&gt;stringIdsSize);</span><br><span class="line">    <span class="keyword">return</span> &amp;pDexFile-&gt;pStringIds[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* return the UTF-8 encoded string with the specified string_id index */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> <span class="type">char</span>* <span class="title">dexStringById</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> DexStringId* pStringId = <span class="built_in">dexGetStringId</span>(pDexFile, idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexGetStringData</span>(pDexFile, pStringId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the UTF-8 encoded string with the specified string_id index,</span></span><br><span class="line"><span class="comment"> * also filling in the UTF-16 size (number of 16-bit code points).*/</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">dexStringAndSizeById</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx,</span></span></span><br><span class="line"><span class="params"><span class="function">        u4* utf16Size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the TypeId with the specified index */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexTypeId* <span class="title">dexGetTypeId</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pDexFile-&gt;pHeader-&gt;typeIdsSize);</span><br><span class="line">    <span class="keyword">return</span> &amp;pDexFile-&gt;pTypeIds[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the descriptor string associated with a given type index.</span></span><br><span class="line"><span class="comment"> * The caller should not free() the returned string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> <span class="type">char</span>* <span class="title">dexStringByTypeIdx</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> DexTypeId* typeId = <span class="built_in">dexGetTypeId</span>(pDexFile, idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexStringById</span>(pDexFile, typeId-&gt;descriptorIdx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the MethodId with the specified index */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexMethodId* <span class="title">dexGetMethodId</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pDexFile-&gt;pHeader-&gt;methodIdsSize);</span><br><span class="line">    <span class="keyword">return</span> &amp;pDexFile-&gt;pMethodIds[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the FieldId with the specified index */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexFieldId* <span class="title">dexGetFieldId</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pDexFile-&gt;pHeader-&gt;fieldIdsSize);</span><br><span class="line">    <span class="keyword">return</span> &amp;pDexFile-&gt;pFieldIds[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the ProtoId with the specified index */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexProtoId* <span class="title">dexGetProtoId</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pDexFile-&gt;pHeader-&gt;protoIdsSize);</span><br><span class="line">    <span class="keyword">return</span> &amp;pDexFile-&gt;pProtoIds[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the parameter list from a ProtoId. The returns NULL if the ProtoId</span></span><br><span class="line"><span class="comment"> * does not have a parameter list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexTypeList* <span class="title">dexGetProtoParameters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile *pDexFile, <span class="type">const</span> DexProtoId* pProtoId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pProtoId-&gt;parametersOff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexTypeList*)</span><br><span class="line">        (pDexFile-&gt;baseAddr + pProtoId-&gt;parametersOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the ClassDef with the specified index */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexClassDef* <span class="title">dexGetClassDef</span><span class="params">(<span class="type">const</span> DexFile* pDexFile, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pDexFile-&gt;pHeader-&gt;classDefsSize);</span><br><span class="line">    <span class="keyword">return</span> &amp;pDexFile-&gt;pClassDefs[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* given a ClassDef pointer, recover its index */</span></span><br><span class="line"><span class="function">DEX_INLINE u4 <span class="title">dexGetIndexForClassDef</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(pClassDef &gt;= pDexFile-&gt;pClassDefs &amp;&amp;</span><br><span class="line">           pClassDef &lt; pDexFile-&gt;pClassDefs + pDexFile-&gt;pHeader-&gt;classDefsSize);</span><br><span class="line">    <span class="keyword">return</span> pClassDef - pDexFile-&gt;pClassDefs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the interface list for a DexClass */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexTypeList* <span class="title">dexGetInterfacesList</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pClassDef-&gt;interfacesOff == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexTypeList*)</span><br><span class="line">        (pDexFile-&gt;baseAddr + pClassDef-&gt;interfacesOff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* return the Nth entry in a DexTypeList. */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexTypeItem* <span class="title">dexGetTypeItem</span><span class="params">(<span class="type">const</span> DexTypeList* pList,</span></span></span><br><span class="line"><span class="params"><span class="function">    u4 idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pList-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> &amp;pList-&gt;list[idx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* return the type_idx for the Nth entry in a TypeList */</span></span><br><span class="line"><span class="function">DEX_INLINE u4 <span class="title">dexTypeListGetIdx</span><span class="params">(<span class="type">const</span> DexTypeList* pList, u4 idx)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> DexTypeItem* pItem = <span class="built_in">dexGetTypeItem</span>(pList, idx);</span><br><span class="line">    <span class="keyword">return</span> pItem-&gt;typeIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the static values list for a DexClass */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexEncodedArray* <span class="title">dexGetStaticValuesList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pClassDef-&gt;staticValuesOff == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexEncodedArray*)</span><br><span class="line">        (pDexFile-&gt;baseAddr + pClassDef-&gt;staticValuesOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the annotations directory item for a DexClass */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationsDirectoryItem* <span class="title">dexGetAnnotationsDirectoryItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pClassDef-&gt;annotationsOff == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexAnnotationsDirectoryItem*)</span><br><span class="line">        (pDexFile-&gt;baseAddr + pClassDef-&gt;annotationsOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the source file string */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> <span class="type">char</span>* <span class="title">dexGetSourceFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pClassDef-&gt;sourceFileIdx == <span class="number">0xffffffff</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexStringById</span>(pDexFile, pClassDef-&gt;sourceFileIdx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the size, in bytes, of a DexCode */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">dexGetDexCodeSize</span><span class="params">(<span class="type">const</span> DexCode* pCode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the list of &quot;tries&quot; for the given DexCode. */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexTry* <span class="title">dexGetTries</span><span class="params">(<span class="type">const</span> DexCode* pCode)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> u2* insnsEnd = &amp;pCode-&gt;insns[pCode-&gt;insnsSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round to four bytes.</span></span><br><span class="line">    <span class="keyword">if</span> ((((<span class="type">uintptr_t</span>) insnsEnd) &amp; <span class="number">3</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        insnsEnd++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexTry*) insnsEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the base of the encoded data for the given DexCode. */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> u1* <span class="title">dexGetCatchHandlerData</span><span class="params">(<span class="type">const</span> DexCode* pCode)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> DexTry* pTries = <span class="built_in">dexGetTries</span>(pCode);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> u1*) &amp;pTries[pCode-&gt;triesSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get a pointer to the start of the debugging data */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> u1* <span class="title">dexGetDebugInfoStream</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexCode* pCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pCode-&gt;debugInfoOff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pDexFile-&gt;baseAddr + pCode-&gt;debugInfoOff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexClassDef convenience - get class descriptor */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> <span class="type">char</span>* <span class="title">dexGetClassDescriptor</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexStringByTypeIdx</span>(pDexFile, pClassDef-&gt;classIdx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexClassDef convenience - get superclass descriptor */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> <span class="type">char</span>* <span class="title">dexGetSuperClassDescriptor</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pClassDef-&gt;superclassIdx == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexStringByTypeIdx</span>(pDexFile, pClassDef-&gt;superclassIdx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexClassDef convenience - get class_data_item pointer */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> u1* <span class="title">dexGetClassData</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexClassDef* pClassDef)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pClassDef-&gt;classDataOff == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> u1*) (pDexFile-&gt;baseAddr + pClassDef-&gt;classDataOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get an annotation set at a particular offset. */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationSetItem* <span class="title">dexGetAnnotationSetItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, u4 offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexAnnotationSetItem*) (pDexFile-&gt;baseAddr + offset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* get the class&#x27; annotation set */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationSetItem* <span class="title">dexGetClassAnnotationSet</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexAnnotationsDirectoryItem* pAnnoDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexGetAnnotationSetItem</span>(pDexFile, pAnnoDir-&gt;classAnnotationsOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the class&#x27; field annotation list */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexFieldAnnotationsItem* <span class="title">dexGetFieldAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexAnnotationsDirectoryItem* pAnnoDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pAnnoDir-&gt;fieldsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip past the header to the start of the field annotations.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexFieldAnnotationsItem*) &amp;pAnnoDir[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get field annotation list size */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">int</span> <span class="title">dexGetFieldAnnotationsSize</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexAnnotationsDirectoryItem* pAnnoDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pAnnoDir-&gt;fieldsSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return a pointer to the field&#x27;s annotation set */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationSetItem* <span class="title">dexGetFieldAnnotationSetItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexFieldAnnotationsItem* pItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexGetAnnotationSetItem</span>(pDexFile, pItem-&gt;annotationsOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the class&#x27; method annotation list */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexMethodAnnotationsItem* <span class="title">dexGetMethodAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexAnnotationsDirectoryItem* pAnnoDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pAnnoDir-&gt;methodsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Skip past the header and field annotations to the start of the</span></span><br><span class="line"><span class="comment">     * method annotations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> u1* addr = (<span class="type">const</span> u1*) &amp;pAnnoDir[<span class="number">1</span>];</span><br><span class="line">    addr += pAnnoDir-&gt;fieldsSize * <span class="built_in">sizeof</span> (DexFieldAnnotationsItem);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexMethodAnnotationsItem*) addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get method annotation list size */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">int</span> <span class="title">dexGetMethodAnnotationsSize</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexAnnotationsDirectoryItem* pAnnoDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pAnnoDir-&gt;methodsSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return a pointer to the method&#x27;s annotation set */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationSetItem* <span class="title">dexGetMethodAnnotationSetItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexMethodAnnotationsItem* pItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexGetAnnotationSetItem</span>(pDexFile, pItem-&gt;annotationsOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the class&#x27; parameter annotation list */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexParameterAnnotationsItem* <span class="title">dexGetParameterAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexAnnotationsDirectoryItem* pAnnoDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pAnnoDir-&gt;parametersSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Skip past the header, field annotations, and method annotations</span></span><br><span class="line"><span class="comment">     * to the start of the parameter annotations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> u1* addr = (<span class="type">const</span> u1*) &amp;pAnnoDir[<span class="number">1</span>];</span><br><span class="line">    addr += pAnnoDir-&gt;fieldsSize * <span class="built_in">sizeof</span> (DexFieldAnnotationsItem);</span><br><span class="line">    addr += pAnnoDir-&gt;methodsSize * <span class="built_in">sizeof</span> (DexMethodAnnotationsItem);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexParameterAnnotationsItem*) addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get method annotation list size */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">int</span> <span class="title">dexGetParameterAnnotationsSize</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexAnnotationsDirectoryItem* pAnnoDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pAnnoDir-&gt;parametersSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the parameter annotation ref list */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationSetRefList* <span class="title">dexGetParameterAnnotationSetRefList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexParameterAnnotationsItem* pItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pItem-&gt;annotationsOff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexAnnotationSetRefList*) (pDexFile-&gt;baseAddr + pItem-&gt;annotationsOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get method annotation list size */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">int</span> <span class="title">dexGetParameterAnnotationSetRefSize</span><span class="params">(<span class="type">const</span> DexFile* pDexFile,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexParameterAnnotationsItem* pItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pItem-&gt;annotationsOff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexGetParameterAnnotationSetRefList</span>(pDexFile, pItem)-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the Nth entry from an annotation set ref list */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationSetRefItem* <span class="title">dexGetParameterAnnotationSetRef</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexAnnotationSetRefList* pList, u4 idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pList-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> &amp;pList-&gt;list[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* given a DexAnnotationSetRefItem, return the DexAnnotationSetItem */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationSetItem* <span class="title">dexGetSetRefItemItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexAnnotationSetRefItem* pItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dexGetAnnotationSetItem</span>(pDexFile, pItem-&gt;annotationsOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the Nth annotation offset from a DexAnnotationSetItem */</span></span><br><span class="line"><span class="function">DEX_INLINE u4 <span class="title">dexGetAnnotationOff</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexAnnotationSetItem* pAnnoSet, u4 idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idx &lt; pAnnoSet-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> pAnnoSet-&gt;entries[idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* return the Nth annotation item from a DexAnnotationSetItem */</span></span><br><span class="line"><span class="function">DEX_INLINE <span class="type">const</span> DexAnnotationItem* <span class="title">dexGetAnnotationItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DexFile* pDexFile, <span class="type">const</span> DexAnnotationSetItem* pAnnoSet, u4 idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u4 offset = <span class="built_in">dexGetAnnotationOff</span>(pAnnoSet, idx);</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">const</span> DexAnnotationItem*) (pDexFile-&gt;baseAddr + offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the type descriptor character associated with a given primitive</span></span><br><span class="line"><span class="comment"> * type. This returns &#x27;\0&#x27; if the type is invalid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">dexGetPrimitiveTypeDescriptorChar</span><span class="params">(PrimitiveType type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the type descriptor string associated with a given primitive</span></span><br><span class="line"><span class="comment"> * type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">dexGetPrimitiveTypeDescriptor</span><span class="params">(PrimitiveType type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the boxed type descriptor string associated with a given</span></span><br><span class="line"><span class="comment"> * primitive type. This returns NULL for an invalid type, including</span></span><br><span class="line"><span class="comment"> * particularly for type &quot;void&quot;. In the latter case, even though there</span></span><br><span class="line"><span class="comment"> * is a class Void, there&#x27;s no such thing as a boxed instance of it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">dexGetBoxedTypeDescriptor</span><span class="params">(PrimitiveType type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the primitive type constant from the given descriptor character.</span></span><br><span class="line"><span class="comment"> * This returns PRIM_NOT (note: this is a 0) if the character is invalid</span></span><br><span class="line"><span class="comment"> * as a primitive type descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PrimitiveType <span class="title">dexGetPrimitiveTypeFromDescriptorChar</span><span class="params">(<span class="type">char</span> descriptorChar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// LIBDEX_DEXFILE_H_</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="DexType-java"><a href="#DexType-java" class="headerlink" title="DexType.java"></a>DexType.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pediy.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">//import org.jf.dexlib.Code.Instruction;</span></span><br><span class="line"><span class="comment">//import org.jf.dexlib.Code.InstructionIterator;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DexHeader dexHeader;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexStringId&gt; dexStringId; <span class="comment">//�����ַ���ƫ�ƴ洢</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String &gt; dexStringList;<span class="comment">//�����ַ���</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexTypeId&gt; dexTypeId;<span class="comment">//����dexTypeID</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String &gt; dexTypeList;<span class="comment">//����type</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexProtoId&gt; dexProtoId;<span class="comment">//����dexProtoID</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String &gt; dexProtoIdString;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String &gt; dexProtoIdType;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexTypeList&gt; dexTypeLists;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String &gt; dexProtoList;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexFieldId&gt; dexFieldId;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String &gt; dexFieldList;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexMethodId&gt; dexMethodId;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String &gt; dexMethodList;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexClassDef&gt; dexClassDefs;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;DexClassData&gt; dexClassData;</span><br><span class="line">    <span class="keyword">public</span> DexMapList dexMapLists;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//���캯��</span></span><br><span class="line">    DexType()&#123;</span><br><span class="line">        dexHeader = <span class="keyword">new</span> <span class="title class_">DexHeader</span>();</span><br><span class="line"></span><br><span class="line">        dexStringId = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexStringId&gt;();</span><br><span class="line">        dexStringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line"></span><br><span class="line">        dexTypeId =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexTypeId &gt;();</span><br><span class="line">        dexTypeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line">        dexTypeLists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexTypeList&gt;();</span><br><span class="line"></span><br><span class="line">        dexProtoId = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexProtoId&gt;();</span><br><span class="line">        dexProtoIdString = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line">        dexProtoIdType = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line">        dexProtoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line"></span><br><span class="line">        dexFieldId = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexFieldId&gt;();</span><br><span class="line">        dexFieldList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line"></span><br><span class="line">        dexMethodId = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexMethodId&gt;();</span><br><span class="line">        dexMethodList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String &gt;();</span><br><span class="line"></span><br><span class="line">        dexClassDefs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexClassDef&gt;();</span><br><span class="line">        dexClassData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexClassData&gt;();</span><br><span class="line"></span><br><span class="line">        dexMapLists = <span class="keyword">new</span> <span class="title class_">DexMapList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexHeader&#123;</span></span><br><span class="line"><span class="comment">     *     u1 magic[8];                   //dex�汾��ʶ8��1�ֽ�</span></span><br><span class="line"><span class="comment">     *     u4 checksum;                   //adler32У��1��4�ֽ�</span></span><br><span class="line"><span class="comment">     *     u1 signature[kSHA1DigestLen];  //SHA-1��ϣֵ</span></span><br><span class="line"><span class="comment">     *     u4 fileSize;                   //�����ļ��Ĵ�С</span></span><br><span class="line"><span class="comment">     *     u4 headerSize;                 //DexHeader�Ľṹ��С</span></span><br><span class="line"><span class="comment">     *     u4 endianTag;                  //�ֽ�����</span></span><br><span class="line"><span class="comment">     *     u4 linkSize;                   //���Ӷδ�С</span></span><br><span class="line"><span class="comment">     *     u4 linkOff;                    //���Ӷ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 mapOff;                     //DexMapList���ļ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 stringIdsSize;              //DexStringId�ĸ���</span></span><br><span class="line"><span class="comment">     *     u4 stringIdsOff;               //DexStringId���ļ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 typeIdsSize;                //DexTupeID�ĸ���</span></span><br><span class="line"><span class="comment">     *     u4 typeIdsOff;                 //DexTypeId���ļ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 protoIdsSize;               //DexProtoId�ĸ���</span></span><br><span class="line"><span class="comment">     *     u4 protoIdsOff;                //DexProtoId���ļ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 fieldIdsSize;               //DexFieldId�ĸ���</span></span><br><span class="line"><span class="comment">     *     u4 fieldIdsOff;                //DexFieldId���ļ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 methodIdsSize;              //DexMethodId�ĸ���</span></span><br><span class="line"><span class="comment">     *     u4 methodIdsOff;               //DexMethodID���ļ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 classDefsSize;              //DexClassDef�ĸ���</span></span><br><span class="line"><span class="comment">     *     u4 classDefsOff;               //DexClassDef���ļ�ƫ��</span></span><br><span class="line"><span class="comment">     *     u4 dataSize;                   //���ݶεĴ�С</span></span><br><span class="line"><span class="comment">     *     u4 dataOff;                    //���ݶε��ļ�ƫ��</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexHeader</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] magic = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];          <span class="comment">//dex�汾��ʶ</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] checksum = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//adler32У��</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] signature = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];     <span class="comment">//sha-1��ϣֵ</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] fileSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//�����ļ��Ĵ�С</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] headerSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];     <span class="comment">//DexHeader�ṹ��С</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] endianTag = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];      <span class="comment">//��С��</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] linkSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//���Ӷδ�С</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] linkOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//���Ӷ�ƫ��</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] mapOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//DexMapList���ļ�ƫ��</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] stringIdsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//DexStringId�ĸ���</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] stringIdsOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//DexStringId���ļ�ƫ��</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] typeIdsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] typeIdsOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] protoIdsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] protoIdsOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] fieldIdsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] fieldIdsOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] methodIdsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] methodIdsOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] classDefsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] classDefsOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] dataSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] dataOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];       <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;<span class="type">byte</span>[]&gt; em = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DexHeader</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.em.add(magic);</span><br><span class="line">            <span class="built_in">this</span>.em.add(checksum);</span><br><span class="line">            <span class="built_in">this</span>.em.add(signature);</span><br><span class="line">            <span class="built_in">this</span>.em.add(fileSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(headerSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(endianTag);</span><br><span class="line">            <span class="built_in">this</span>.em.add(linkSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(linkOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(mapOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(stringIdsSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(stringIdsOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(typeIdsSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(typeIdsOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(protoIdsSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(protoIdsOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(fieldIdsSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(fieldIdsOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(methodIdsSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(methodIdsOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(classDefsSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(classDefsOff);</span><br><span class="line">            <span class="built_in">this</span>.em.add(dataSize);</span><br><span class="line">            <span class="built_in">this</span>.em.add(dataOff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexStringId&#123;</span></span><br><span class="line"><span class="comment">     *      u4 stringDataOff;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexStringId</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] stringDataOff= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexTypeId&#123;</span></span><br><span class="line"><span class="comment">     *     u4 descriptorIdx;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexTypeId</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] descriptorIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexProtoId&#123;</span></span><br><span class="line"><span class="comment">     *     u4 shortyIdx;</span></span><br><span class="line"><span class="comment">     *     u4 returnTypeIdx;</span></span><br><span class="line"><span class="comment">     *     u4 parametersOff;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexProtoId</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] shortyIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] returnTypeIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] parametersOff=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> List&lt;DexTypeItem&gt; dexTypeItemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexTypeItem&#123;</span></span><br><span class="line"><span class="comment">     *     u2 typeIdx;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexTypeItem</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] typeIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexTypeList&#123;</span></span><br><span class="line"><span class="comment">     *     u4 size;</span></span><br><span class="line"><span class="comment">     *     DexTypeItem list[11;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexTypeList</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] size=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;DexTypeItem&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexTypeItem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexFieldId&#123;</span></span><br><span class="line"><span class="comment">     *     u4 classIdx;</span></span><br><span class="line"><span class="comment">     *     u4 typeIdx;</span></span><br><span class="line"><span class="comment">     *     u4 nameIdx;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexFieldId</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] classIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] typeIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] nameIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexMethodId&#123;</span></span><br><span class="line"><span class="comment">     *     u4 classIdx;</span></span><br><span class="line"><span class="comment">     *     u4 protoIdx;</span></span><br><span class="line"><span class="comment">     *     u4 nameIdx;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexMethodId</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] classIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] protoIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] nameIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexClassDef&#123;</span></span><br><span class="line"><span class="comment">     *     u4 classIdx;</span></span><br><span class="line"><span class="comment">     *     u4 accessFlags;</span></span><br><span class="line"><span class="comment">     *     u4 superclassIdx;</span></span><br><span class="line"><span class="comment">     *     u4 interfacesOff;</span></span><br><span class="line"><span class="comment">     *     u4 sourceFileIdx;</span></span><br><span class="line"><span class="comment">     *     u4 annotationsOff;</span></span><br><span class="line"><span class="comment">     *     u4 classDataOff;</span></span><br><span class="line"><span class="comment">     *     u4 staticValuesOff;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexClassDef</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] classIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] accessFlags=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] superclassIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] interfacesOff=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] sourceFileIdx=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] annotationsOff=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] classDataOff=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] staticValuesOff=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexClassDataItem&#123;</span></span><br><span class="line"><span class="comment">     *     u4 staticFieldsSize;</span></span><br><span class="line"><span class="comment">     *     u4 instanceFieldsSize;</span></span><br><span class="line"><span class="comment">     *     u4 directMethodsSize;</span></span><br><span class="line"><span class="comment">     *     u4 virtualMethodsSize;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexClassDataItem</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] staticFieldsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] instanceFieldsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] directMethodsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] virtualMethodsSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexCodeItem</span>&#123;</span><br><span class="line">        <span class="type">short</span> registers_size ;</span><br><span class="line">        <span class="type">short</span> ins_size ;</span><br><span class="line">        <span class="type">short</span> outs_size ;</span><br><span class="line">        <span class="type">short</span> tries_size ;</span><br><span class="line">        <span class="type">int</span> debug_info_off ;</span><br><span class="line">        <span class="type">int</span> insns_size;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; insns ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DexCodeItem</span><span class="params">(<span class="type">byte</span>[] pBuff, <span class="type">int</span> pOff)</span> &#123;</span><br><span class="line">            registers_size = Utils.byte2Short_2(pBuff, pOff + <span class="number">0</span>);</span><br><span class="line">            ins_size = Utils.byte2Short_2(pBuff, pOff + <span class="number">2</span>);</span><br><span class="line">            outs_size = Utils.byte2Short_2(pBuff, pOff + <span class="number">4</span>);</span><br><span class="line">            tries_size = Utils.byte2Short_2(pBuff, pOff + <span class="number">6</span>);</span><br><span class="line">            debug_info_off = Utils.byte2Int_4(pBuff, pOff + <span class="number">8</span>);</span><br><span class="line">            insns_size = Utils.byte2Int_4(pBuff, pOff + <span class="number">12</span>);</span><br><span class="line">            insns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;\tCodeItem:\t.registers:%d, ������������:%d, ���������������ʱ��Ҫ�Ĳ�������:%d, try_item����:%d, %d,%d\r\n&quot;</span>, registers_size, ins_size, outs_size, tries_size, debug_info_off, insns_size);</span><br><span class="line">            <span class="type">byte</span>[] ttmp = <span class="keyword">new</span> <span class="title class_">byte</span>[insns_size*<span class="number">2</span>];</span><br><span class="line">            System.arraycopy(pBuff, pOff+<span class="number">16</span>, ttmp, <span class="number">0</span>, ttmp.length);</span><br><span class="line">            ParseDex.getOpcodeByIns2(ttmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            for (int i=0; i&lt;insns_size; i++)&#123;</span></span><br><span class="line"><span class="comment">//                byte[] tmp = new byte[2];</span></span><br><span class="line"><span class="comment">//                System.arraycopy(pBuff, pOff + 16+i*2, tmp, 0, 2);</span></span><br><span class="line"><span class="comment">//                insns.add(tmp);</span></span><br><span class="line"><span class="comment">////                System.out.printf(&quot;\t\t&quot;+ParseDex.getOpcodeByIns2(tmp));</span></span><br><span class="line"><span class="comment">////                System.out.printf(&quot;: &quot; + Utils.bytes2HexString(tmp) + &quot;\r\n&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize_CodeItem</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> insns_size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexField&#123;</span></span><br><span class="line"><span class="comment">     *     u4 fieldIdx;</span></span><br><span class="line"><span class="comment">     *     u4 accessFlags;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexField</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] fieldIdx = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] accessFlags = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexMethod&#123;</span></span><br><span class="line"><span class="comment">     *     u4 methodIdx;</span></span><br><span class="line"><span class="comment">     *     u4 accessFlags;</span></span><br><span class="line"><span class="comment">     *     u4 codoOff;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexMethod</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] methodIdx = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] accessFlags = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] codeOff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexClassData&#123;</span></span><br><span class="line"><span class="comment">     *     DexClassDataItem header;</span></span><br><span class="line"><span class="comment">     *     DexField* staticFields;</span></span><br><span class="line"><span class="comment">     *     DexField* instanceFields;</span></span><br><span class="line"><span class="comment">     *     DexMethod* directMethods;</span></span><br><span class="line"><span class="comment">     *     DexMethod* virtualMethods</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexClassData</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;DexClassDataItem&gt; dexClassDataItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexClassDataItem&gt;();</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;DexField&gt; staticFields = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexField&gt;();</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;DexField&gt; instanceFields = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexField&gt;();</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;DexMethod&gt; directMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexMethod&gt;();</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;DexMethod&gt; virtualMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexMethod&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexMapItem&#123;</span></span><br><span class="line"><span class="comment">     *     u2 type;</span></span><br><span class="line"><span class="comment">     *     u2 unused;</span></span><br><span class="line"><span class="comment">     *     u4 size;</span></span><br><span class="line"><span class="comment">     *     u4 offset;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexMapItem</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] type=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] unused=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] size=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] offset=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * typedef struct DexMapList&#123;</span></span><br><span class="line"><span class="comment">     *     u4 size;</span></span><br><span class="line"><span class="comment">     *     DexMapItem list[11;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DexMapList</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] size=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;DexMapItem&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DexMapItem&gt;();</span><br><span class="line">        <span class="keyword">public</span> Map&lt;Integer, String&gt; type_code = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DexMapList</span><span class="params">()</span> &#123;</span><br><span class="line">            type_code.put(<span class="number">0x0000</span>, <span class="string">&quot;TYPE_HEADER_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x0001</span>, <span class="string">&quot;TYPE_STRING_ID_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x0002</span>, <span class="string">&quot;TYPE_TYPE_ID_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x0003</span>, <span class="string">&quot;TYPE_PROTO_ID_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x0004</span>, <span class="string">&quot;TYPE_FIELD_ID_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x0005</span>, <span class="string">&quot;TYPE_METHOD_ID_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x0006</span>, <span class="string">&quot;TYPE_CLASS_DEF_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x1000</span>, <span class="string">&quot;TYPE_MAP_LIST&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x1001</span>, <span class="string">&quot;TYPE_TYPE_LIST&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x1002</span>, <span class="string">&quot;TYPE_ANNOTATION_SET_REF_LIST&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x1003</span>, <span class="string">&quot;TYPE_ANNOTATION_SET_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x2000</span>, <span class="string">&quot;TYPE_CLASS_DATA_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x2001</span>, <span class="string">&quot;TYPE_CODE_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x2002</span>, <span class="string">&quot;TYPE_STRING_DATA_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x2003</span>, <span class="string">&quot;TYPE_DEBUG_INFO_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x2004</span>, <span class="string">&quot;TYPE_ANNOTATION_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x2005</span>, <span class="string">&quot;TYPE_ENCODED_ARRAY_ITEM&quot;</span>);</span><br><span class="line">            type_code.put(<span class="number">0x2006</span>, <span class="string">&quot;TYPE_ANNOTATIONS_DIRECTORY_ITEM&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Main-java"><a href="#Main-java" class="headerlink" title="Main.java"></a>Main.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pediy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	    <span class="type">String</span> <span class="variable">dexPath</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld.dex&quot;</span>;</span><br><span class="line">	    <span class="type">byte</span>[] fileByteArrays = Utils.readFile(dexPath);</span><br><span class="line">	    <span class="keyword">if</span> (fileByteArrays == <span class="literal">null</span>)&#123;</span><br><span class="line">	        System.out.println(<span class="string">&quot;read file filed&quot;</span>);</span><br><span class="line">	        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="type">ParseDex</span> <span class="variable">parseDex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseDex</span>(fileByteArrays);</span><br><span class="line">	    parseDex.parse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ParseDex-java"><a href="#ParseDex-java" class="headerlink" title="ParseDex.java"></a>ParseDex.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pediy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jf.dexlib2.Opcode;</span><br><span class="line"><span class="keyword">import</span> org.jf.dexlib2.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParseDex</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">byte</span>[] byteData;</span><br><span class="line">    <span class="keyword">private</span> DexType dexType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParseDex</span><span class="params">(<span class="type">byte</span>[] pArr)</span> &#123;</span><br><span class="line">        byteData = pArr;</span><br><span class="line">        dexType = <span class="keyword">new</span> <span class="title class_">DexType</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span>&#123;</span><br><span class="line">        parseHeader(<span class="number">0</span>);</span><br><span class="line">        printHeader();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">stringOff</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.stringIdsOff, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">stringSize</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.stringIdsSize, <span class="number">0</span>);</span><br><span class="line">        readDexStringId(stringOff, stringSize);</span><br><span class="line">        printStrings();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">typeOff</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.typeIdsOff, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeSize</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.typeIdsSize, <span class="number">0</span>);</span><br><span class="line">        readDexTypeId(typeOff, typeSize);</span><br><span class="line">        printTypes();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">protoOff</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.protoIdsOff, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">protoSize</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.protoIdsSize, <span class="number">0</span>);</span><br><span class="line">        readDexProtoId(protoOff, protoSize);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">fieldOff</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.fieldIdsOff, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fieldSize</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.fieldIdsSize, <span class="number">0</span>);</span><br><span class="line">        readDexFieldId(fieldOff, fieldSize);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">methodOff</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.methodIdsOff, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">methodSize</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.methodIdsSize, <span class="number">0</span>);</span><br><span class="line">        readDexMethodId(methodOff, methodSize);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">classOff</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.classDefsOff, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">classSize</span> <span class="operator">=</span> Utils.byte2Int_4(dexType.dexHeader.classDefsSize, <span class="number">0</span>);</span><br><span class="line">        readDexClassDefsId(classOff, classSize);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getStringById</span><span class="params">(<span class="type">int</span> pId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dexType.dexStringList.get(pId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getTypeStringById</span><span class="params">(<span class="type">int</span> pId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dexType.dexTypeList.get(pId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getProtoStringById</span><span class="params">(<span class="type">int</span> pId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dexType.dexProtoList.get(pId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFieldStringById</span><span class="params">(<span class="type">int</span> pId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dexType.dexFieldList.get(pId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getMethodStringById</span><span class="params">(<span class="type">int</span> pId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dexType.dexMethodList.get(pId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseHeader</span><span class="params">(<span class="type">int</span> offset)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (byteData == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;byteData is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.arraycopy(byteData, 0, dexType.dexHeader.magic, 0, dexType.dexHeader.magic.length);</span></span><br><span class="line"><span class="comment">//        System.arraycopy(byteData, 0+dexType.dexHeader.magic.length, dexType.dexHeader.checksum, 0, dexType.dexHeader.checksum.length);</span></span><br><span class="line"><span class="comment">//        System.arraycopy(byteData, 0+dexType.dexHeader.checksum.length, dexType.dexHeader.signature, 0, dexType.dexHeader.signature.length);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curPos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; dexType.dexHeader.em.size(); i++)&#123;</span><br><span class="line">            System.arraycopy(byteData, curPos, dexType.dexHeader.em.get(i), <span class="number">0</span>, dexType.dexHeader.em.get(i).length);</span><br><span class="line">            curPos += dexType.dexHeader.em.get(i).length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHeader</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%-12s: %s\r\n&quot;</span>, <span class="string">&quot;magic&quot;</span>, Utils.bytes2HexString(dexType.dexHeader.magic));</span><br><span class="line">        System.out.printf(<span class="string">&quot;%-12s: %s\r\n&quot;</span>, <span class="string">&quot;checksum&quot;</span>, Utils.bytes2HexString(dexType.dexHeader.checksum));</span><br><span class="line">        System.out.printf(<span class="string">&quot;%-12s: %s\r\n&quot;</span>, <span class="string">&quot;signature&quot;</span>, Utils.bytes2HexString(dexType.dexHeader.signature));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readDexStringId</span><span class="params">(<span class="type">int</span> pOff, <span class="type">int</span> pCount)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pCount; i++)&#123;</span><br><span class="line">            DexType.<span class="type">DexStringId</span> <span class="variable">t_dexStringId</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexStringId</span>();</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">4</span>, t_dexStringId.stringDataOff, <span class="number">0</span>, t_dexStringId.stringDataOff.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">dexStringId</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexStringId.stringDataOff, <span class="number">0</span>);</span><br><span class="line">            Utils.<span class="type">RETULEB128</span> <span class="variable">tmp</span> <span class="operator">=</span> Utils.readULEB128(byteData, dexStringId);</span><br><span class="line">            <span class="type">byte</span>[] strContent = Utils.copyNewBytes(byteData, dexStringId+tmp.readSize, tmp.retValue);</span><br><span class="line">            <span class="type">String</span> <span class="variable">realString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(strContent);</span><br><span class="line"></span><br><span class="line">            dexType.dexStringId.add(t_dexStringId);</span><br><span class="line">            dexType.dexStringList.add(realString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printStrings</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------strings----------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;dexType.dexStringList.size(); i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\t&quot;</span> + dexType.dexStringList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readDexTypeId</span><span class="params">(<span class="type">int</span> pOff, <span class="type">int</span> pCount)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pCount; i++)&#123;</span><br><span class="line">            DexType.<span class="type">DexTypeId</span> <span class="variable">t_dexTypeId</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexTypeId</span>();</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">4</span>, t_dexTypeId.descriptorIdx, <span class="number">0</span>, t_dexTypeId.descriptorIdx.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">dexTypeId</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexTypeId.descriptorIdx, <span class="number">0</span>);</span><br><span class="line">            dexType.dexTypeId.add(t_dexTypeId);</span><br><span class="line">            dexType.dexTypeList.add(getStringById(dexTypeId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printTypes</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------types----------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String one:dexType.dexTypeList) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\t&quot;</span> + one);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readDexProtoId</span><span class="params">(<span class="type">int</span> pOff, <span class="type">int</span> pCount)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pCount; i++)&#123;</span><br><span class="line">            DexType.<span class="type">DexProtoId</span> <span class="variable">t_dexProtoId</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexProtoId</span>();</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">12</span>*i+<span class="number">0</span>, t_dexProtoId.shortyIdx, <span class="number">0</span>, t_dexProtoId.shortyIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">12</span>*i+<span class="number">4</span>, t_dexProtoId.returnTypeIdx, <span class="number">0</span>, t_dexProtoId.returnTypeIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">12</span>*i+<span class="number">8</span>, t_dexProtoId.parametersOff, <span class="number">0</span>, t_dexProtoId.parametersOff.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">pri</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">shorty_string</span> <span class="operator">=</span> getStringById(Utils.byte2Int_4(t_dexProtoId.shortyIdx, <span class="number">0</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">return_type_idx</span> <span class="operator">=</span> getStringById(Utils.byte2Int_4(t_dexProtoId.returnTypeIdx, <span class="number">0</span>));</span><br><span class="line">            pri += (shorty_string + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            pri += (return_type_idx + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">parameters_Off</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexProtoId.parametersOff, <span class="number">0</span>);</span><br><span class="line">            pri += <span class="string">&quot;(&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (parameters_Off == <span class="number">0</span>)&#123;</span><br><span class="line">                dexType.dexProtoId.add(t_dexProtoId);</span><br><span class="line">                dexType.dexProtoList.add(getTypeStringById(Utils.byte2Int_4(t_dexProtoId.returnTypeIdx, <span class="number">0</span>)));</span><br><span class="line">                pri += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">structCount</span> <span class="operator">=</span> Utils.byte2Int_4(byteData, parameters_Off);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;structCount; j++)&#123;</span><br><span class="line">                DexType.<span class="type">DexTypeItem</span> <span class="variable">t_dexTypeItem</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexTypeItem</span>();</span><br><span class="line">                System.arraycopy(byteData, parameters_Off+<span class="number">4</span>+j*t_dexTypeItem.typeIdx.length, t_dexTypeItem.typeIdx, <span class="number">0</span>, t_dexTypeItem.typeIdx.length);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> Utils.byte2Short_2(t_dexTypeItem.typeIdx, <span class="number">0</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> getTypeStringById(tmp);</span><br><span class="line">                pri += (p + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pri += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            System.out.println(pri);</span><br><span class="line"></span><br><span class="line">            dexType.dexProtoId.add(t_dexProtoId);</span><br><span class="line">            dexType.dexProtoList.add(getTypeStringById(Utils.byte2Int_4(t_dexProtoId.returnTypeIdx, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readDexFieldId</span><span class="params">(<span class="type">int</span> pOff, <span class="type">int</span> pCount)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------fields----------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pCount; i++)&#123;</span><br><span class="line">            DexType.<span class="type">DexFieldId</span> <span class="variable">t_dexFieldId</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexFieldId</span>();</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">8</span>*i+<span class="number">0</span>, t_dexFieldId.classIdx, <span class="number">0</span>, t_dexFieldId.classIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">8</span>*i+<span class="number">2</span>, t_dexFieldId.typeIdx, <span class="number">0</span>, t_dexFieldId.typeIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">8</span>*i+<span class="number">4</span>, t_dexFieldId.nameIdx, <span class="number">0</span>, t_dexFieldId.nameIdx.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">classIdx</span> <span class="operator">=</span> Utils.byte2Short_2(t_dexFieldId.classIdx, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">typeIdx</span> <span class="operator">=</span> Utils.byte2Short_2(t_dexFieldId.typeIdx, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">nameIdx</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexFieldId.nameIdx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">pri</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            pri += (<span class="string">&quot;class:&quot;</span>+getTypeStringById(classIdx) + <span class="string">&quot;, type:&quot;</span> + getTypeStringById(typeIdx) + <span class="string">&quot;, name:&quot;</span>+getStringById(nameIdx));</span><br><span class="line">            System.out.println(pri);</span><br><span class="line"></span><br><span class="line">            dexType.dexFieldId.add(t_dexFieldId);</span><br><span class="line">            dexType.dexFieldList.add(getStringById(nameIdx));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readDexMethodId</span><span class="params">(<span class="type">int</span> pOff, <span class="type">int</span> pCount)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------methods----------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pCount; i++)&#123;</span><br><span class="line">            DexType.<span class="type">DexMethodId</span> <span class="variable">t_dexMethodId</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexMethodId</span>();</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">8</span>*i+<span class="number">0</span>, t_dexMethodId.classIdx, <span class="number">0</span>, t_dexMethodId.classIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">8</span>*i+<span class="number">2</span>, t_dexMethodId.protoIdx, <span class="number">0</span>, t_dexMethodId.protoIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+<span class="number">8</span>*i+<span class="number">4</span>, t_dexMethodId.nameIdx, <span class="number">0</span>, t_dexMethodId.nameIdx.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">classIdx</span> <span class="operator">=</span> Utils.byte2Short_2(t_dexMethodId.classIdx, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">protoIdx</span> <span class="operator">=</span> Utils.byte2Short_2(t_dexMethodId.protoIdx, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">nameIdx</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexMethodId.nameIdx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">pri</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            pri += (<span class="string">&quot;class:&quot;</span>+getTypeStringById(classIdx) + <span class="string">&quot;, proto:&quot;</span> + getProtoStringById(protoIdx) + <span class="string">&quot;, name:&quot;</span>+getStringById(nameIdx));</span><br><span class="line">            System.out.println(pri);</span><br><span class="line"></span><br><span class="line">            dexType.dexMethodId.add(t_dexMethodId);</span><br><span class="line">            dexType.dexMethodList.add(getStringById(nameIdx));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readDexClassDefsId</span><span class="params">(<span class="type">int</span> pOff, <span class="type">int</span> pCount)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------ClassDefs----------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pCount; i++)&#123;</span><br><span class="line">            DexType.<span class="type">DexClassDef</span> <span class="variable">t_dexClassDef</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexClassDef</span>();</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">0</span>, t_dexClassDef.classIdx, <span class="number">0</span>, t_dexClassDef.classIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">4</span>, t_dexClassDef.accessFlags, <span class="number">0</span>, t_dexClassDef.accessFlags.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">8</span>, t_dexClassDef.superclassIdx, <span class="number">0</span>, t_dexClassDef.superclassIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">12</span>, t_dexClassDef.interfacesOff, <span class="number">0</span>, t_dexClassDef.interfacesOff.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">16</span>, t_dexClassDef.sourceFileIdx, <span class="number">0</span>, t_dexClassDef.sourceFileIdx.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">20</span>, t_dexClassDef.annotationsOff, <span class="number">0</span>, t_dexClassDef.annotationsOff.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">24</span>, t_dexClassDef.classDataOff, <span class="number">0</span>, t_dexClassDef.classDataOff.length);</span><br><span class="line">            System.arraycopy(byteData, pOff+i*<span class="number">32</span>+<span class="number">28</span>, t_dexClassDef.staticValuesOff, <span class="number">0</span>, t_dexClassDef.staticValuesOff.length);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">classIdx</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.classIdx, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.accessFlags, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">superclassIdx</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.superclassIdx, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">interfacesOff</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.interfacesOff, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sourceFileIdx</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.sourceFileIdx, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">annotationsOff</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.annotationsOff, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">classDataOff</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.classDataOff, <span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">staticValuesOff</span> <span class="operator">=</span> Utils.byte2Int_4(t_dexClassDef.staticValuesOff, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">pri</span> <span class="operator">=</span> <span class="string">&quot;classIdx: &quot;</span> + getTypeStringById(classIdx) + <span class="string">&quot;\r\naccessFlags: &quot;</span> + accessFlags + <span class="string">&quot;\r\nsuperclassIdx: &quot;</span></span><br><span class="line">                    + getTypeStringById(superclassIdx) + <span class="string">&quot;\r\ninterfacesOff: &quot;</span>;</span><br><span class="line">            pri += (interfacesOff + <span class="string">&quot;\r\nsourceFileIdx: &quot;</span> + getStringById(sourceFileIdx) + <span class="string">&quot;\r\nannotationsOff: &quot;</span> + annotationsOff + <span class="string">&quot;\r\nclassDataOff: &quot;</span>);</span><br><span class="line">            pri += (classDataOff + <span class="string">&quot;\r\nstaticValuesOff: &quot;</span> + staticValuesOff);</span><br><span class="line">            System.out.println(pri);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (classDataOff == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">off</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            Utils.<span class="type">RETULEB128</span> <span class="variable">retuleb128</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">            <span class="type">int</span> <span class="variable">static_fields_size</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">            off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">            retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">            <span class="type">int</span> <span class="variable">instance_fields_size</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">            off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">            retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">            <span class="type">int</span> <span class="variable">direct_methods_size</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">            off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">            retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">            <span class="type">int</span> <span class="variable">virtual_methods_size</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">            off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;static_fields_size:&quot;</span> + static_fields_size + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;static_fields_size; j++)&#123;</span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">field_idx_diff</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">access_flags</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;\t&quot;</span> + getFieldStringById(field_idx_diff) + <span class="string">&quot;, &quot;</span> + access_flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;instance_fields_size:&quot;</span> + instance_fields_size + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;static_fields_size; j++) &#123;</span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">field_idx_diff</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">access_flags</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;\t&quot;</span> + getFieldStringById(field_idx_diff) + <span class="string">&quot;, &quot;</span> + access_flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;direct_methods_size:&quot;</span> + direct_methods_size + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;direct_methods_size; j++) &#123;</span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">method_idx_diff</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">access_flags</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">code_off</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (code_off &lt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;\t&quot;</span> + getMethodStringById(method_idx_diff) + <span class="string">&quot;, &quot;</span> + access_flags);</span><br><span class="line">                DexType.<span class="type">DexCodeItem</span> <span class="variable">t_dexCodeItem</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexCodeItem</span>(byteData, code_off);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;virtual_methods_size:&quot;</span> + virtual_methods_size + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;virtual_methods_size; j++) &#123;</span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">method_idx_diff</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">access_flags</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                retuleb128 = Utils.readULEB128(byteData, classDataOff + off);</span><br><span class="line">                <span class="type">int</span> <span class="variable">code_off</span> <span class="operator">=</span> retuleb128.retValue;</span><br><span class="line">                off += retuleb128.readSize;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (code_off &lt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;\t&quot;</span> + getMethodStringById(method_idx_diff) + <span class="string">&quot;, &quot;</span> + access_flags);</span><br><span class="line">                DexType.<span class="type">DexCodeItem</span> <span class="variable">t_dexCodeItem</span> <span class="operator">=</span> dexType.<span class="keyword">new</span> <span class="title class_">DexCodeItem</span>(byteData, code_off);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getOpcodeByIns2</span><span class="params">(<span class="type">byte</span>[] insns)</span>&#123;</span><br><span class="line">        <span class="comment">//����λ��org.jf.dexlib2.dexbacked.instruction.DexBackedInstruction  public static Instruction readFrom(DexBackedDexFile dexFile, DexReader reader) &#123;</span></span><br><span class="line">        <span class="type">Opcode</span> <span class="variable">opcode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> insnsPosition=<span class="number">0</span>; insnsPosition&lt;insns.length; insnsPosition += (opcode.format.size/<span class="number">2</span>*<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">opcodeValue</span> <span class="operator">=</span>  (insns[insnsPosition] &amp; <span class="number">255</span>);</span><br><span class="line">                <span class="keyword">if</span> (opcodeValue == <span class="number">0</span>) &#123;</span><br><span class="line">                    opcodeValue = (insns[insnsPosition] &amp; <span class="number">255</span>) | ((insns[insnsPosition + <span class="number">1</span>] &amp; <span class="number">255</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                opcode = Opcodes.forApi(<span class="number">35</span>).getOpcodeByValue(opcodeValue);</span><br><span class="line">                <span class="type">byte</span>[] tmp = <span class="keyword">new</span> <span class="title class_">byte</span>[opcode.format.size/<span class="number">2</span>*<span class="number">2</span>];</span><br><span class="line">                System.arraycopy(insns, insnsPosition, tmp, <span class="number">0</span>, tmp.length);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;\t\t&quot;</span> + opcode.name + <span class="string">&quot; : &quot;</span> + Utils.bytes2HexString(tmp));</span><br><span class="line">                <span class="keyword">if</span> (opcode.format.size &lt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Utils-java"><a href="#Utils-java" class="headerlink" title="Utils.java"></a>Utils.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pediy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">bytes2HexString</span><span class="params">(<span class="type">byte</span>[] bytes)</span>&#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;bytes.length;i++)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> bytes[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(t).toUpperCase();</span><br><span class="line">			<span class="keyword">if</span>(hex.length() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">				result.append(<span class="string">&quot;0&quot;</span>+hex);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				result.append(hex);</span><br><span class="line">			&#125;</span><br><span class="line">			result.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">bytes2HexStringBig</span><span class="params">(<span class="type">byte</span>[] bytes)</span>&#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;bytes.length;i++)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> bytes[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">			<span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(t).toUpperCase();</span><br><span class="line">			<span class="keyword">if</span>(hex.length() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">				result.append(<span class="string">&quot;0&quot;</span>+hex);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				result.append(hex);</span><br><span class="line">			&#125;</span><br><span class="line">			result.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] readFile(String fileName)&#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">			bos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">			<span class="type">byte</span>[] temp = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> ((size = fis.read(temp)) != -<span class="number">1</span>) &#123;</span><br><span class="line">				bos.write(temp, <span class="number">0</span>, size);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;read file error:&quot;</span>+e.toString());</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					fis.close();</span><br><span class="line">				&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;close file error:&quot;</span>+e.toString());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					bos.close();</span><br><span class="line">				&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;close file error:&quot;</span>+e.toString());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] copyNewBytes(<span class="type">byte</span>[] addr,<span class="type">int</span> start,<span class="type">int</span> length)&#123;</span><br><span class="line">		<span class="type">byte</span>[] destByte = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">			destByte[i] = addr[start+i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> destByte;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">byte2Int_4</span><span class="params">(<span class="type">byte</span>[] res, <span class="type">int</span> pOff)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">targets</span> <span class="operator">=</span> (res[pOff+<span class="number">0</span>] &amp; <span class="number">0xff</span>)</span><br><span class="line">				| ((res[pOff+<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>)</span><br><span class="line">				| ((res[pOff+<span class="number">2</span>] &lt;&lt; <span class="number">24</span>) &gt;&gt;&gt; <span class="number">8</span>)</span><br><span class="line">				| (res[pOff+<span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">		<span class="keyword">return</span> targets;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">byte2Short_2</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> pOff)</span> &#123;</span><br><span class="line">		<span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">s0</span> <span class="operator">=</span> (<span class="type">short</span>) (b[pOff+<span class="number">0</span>] &amp; <span class="number">0xff</span>);<span class="comment">// 最低位</span></span><br><span class="line">		<span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> (<span class="type">short</span>) (b[pOff+<span class="number">1</span>] &amp; <span class="number">0xff</span>);</span><br><span class="line">		s1 &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">		s = (<span class="type">short</span>) (s0 | s1);</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RETULEB128</span>&#123;</span><br><span class="line">		<span class="type">int</span> retValue;</span><br><span class="line">		<span class="type">int</span> readSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> RETULEB128 <span class="title function_">readULEB128</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> pOff)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="type">RETULEB128</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RETULEB128</span>();</span><br><span class="line">			<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">if</span> (pOff+i &gt;= data.length)</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;pOff+i &gt;= data.length&quot;</span>);</span><br><span class="line">				<span class="type">int</span> <span class="variable">currentByte</span> <span class="operator">=</span> data[pOff + i];</span><br><span class="line"></span><br><span class="line">				bytesRead++;</span><br><span class="line">				result |= (currentByte &amp; <span class="number">0x7F</span>) &lt;&lt; shift;</span><br><span class="line">				shift += <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((currentByte &amp; <span class="number">0x80</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (bytesRead &gt; <span class="number">5</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Invalid ULEB128 encoded data: more than 5 bytes&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ret.retValue = result;</span><br><span class="line">			ret.readSize = bytesRead;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException ioe)&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> codecs.<span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> codecs.<span class="built_in">open</span>(<span class="string">&#x27;file_gbk.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;gbk&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">lele</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/26/Dex%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/">http://example.com/2024/07/26/Dex%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/01/ELF/" title="ELF"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ELF</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/25/Dex%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%901/" title="Dex代码解析1"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dex代码解析1</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lele</div><div class="author-info__description">且行且看且从容</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Wys-Blog" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1770460890@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#DexFile-h"><span class="toc-number">1.</span> <span class="toc-text">DexFile.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DexType-java"><span class="toc-number">2.</span> <span class="toc-text">DexType.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Main-java"><span class="toc-number">3.</span> <span class="toc-text">Main.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParseDex-java"><span class="toc-number">4.</span> <span class="toc-text">ParseDex.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Utils-java"><span class="toc-number">5.</span> <span class="toc-text">Utils.java</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python%E8%84%9A%E6%9C%AC"><span class="toc-number">6.</span> <span class="toc-text">python脚本</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/01/ListView-and-RecyclerView/" title="ListView and RecyclerView"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ListView and RecyclerView"/></a><div class="content"><a class="title" href="/2024/09/01/ListView-and-RecyclerView/" title="ListView and RecyclerView">ListView and RecyclerView</a><time datetime="2024-09-01T03:07:24.000Z" title="发表于 2024-09-01 11:07:24">2024-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/31/Android%E5%B8%83%E5%B1%80/" title="Android布局"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android布局"/></a><div class="content"><a class="title" href="/2024/08/31/Android%E5%B8%83%E5%B1%80/" title="Android布局">Android布局</a><time datetime="2024-08-31T08:48:21.000Z" title="发表于 2024-08-31 16:48:21">2024-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/Android%E6%8E%A7%E4%BB%B6/" title="Android控件"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android控件"/></a><div class="content"><a class="title" href="/2024/08/29/Android%E6%8E%A7%E4%BB%B6/" title="Android控件">Android控件</a><time datetime="2024-08-29T07:29:32.000Z" title="发表于 2024-08-29 15:29:32">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/28/Java%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE/" title="Java基础项目"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础项目"/></a><div class="content"><a class="title" href="/2024/08/28/Java%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE/" title="Java基础项目">Java基础项目</a><time datetime="2024-08-28T15:58:12.000Z" title="发表于 2024-08-28 23:58:12">2024-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/26/Java%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE7-1/" title="Java基础题目7"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础题目7"/></a><div class="content"><a class="title" href="/2024/08/26/Java%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE7-1/" title="Java基础题目7">Java基础题目7</a><time datetime="2024-08-26T11:41:52.000Z" title="发表于 2024-08-26 19:41:52">2024-08-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By lele</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>